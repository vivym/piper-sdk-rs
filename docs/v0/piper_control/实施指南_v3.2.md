# Piper Control å¯å€Ÿé‰´ç‰¹æ€§å®æ–½æŒ‡å—ï¼ˆv3.2 æœ€ç»ˆä¿®æ­£ç‰ˆï¼‰

**âš ï¸ å…³é”®ä¿®æ­£è¯´æ˜**:
- **v3.0**: çŠ¶æ€æµè½¬ã€é«˜ç²¾åº¦å¾ªç¯ã€Option æ¨¡å¼ã€ç‰ˆæœ¬è§£æï¼ˆ5 ä¸ªæ ¸å¿ƒä¼˜åŒ–ï¼‰
- **v3.1**: å®¹é”™æ€§å¢å¼ºã€Token æ„é€ ã€è½¯é™çº§ç­–ç•¥ï¼ˆ3 ä¸ªå·¥ç¨‹åŒ–å¢å¼ºï¼‰
- **v3.2**: â­ **å¾ªç¯é”šç‚¹ä¿®æ­£**ï¼ˆæ¶ˆé™¤ç´¯ç§¯æ¼‚ç§»ï¼Œä¿è¯ç²¾ç¡® 200Hz æ§åˆ¶é¢‘ç‡ï¼‰

---

## æ ¸å¿ƒå‘ç°æ€»ç»“

ç»è¿‡ **3 è½®è¿­ä»£ + 1 è½®å·¥ç¨‹åŒ–å¢å¼º + 1 è½®ç‰©ç†ä¿®æ­£**ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª**ç”Ÿäº§å°±ç»ª**çš„ Rust SDK è®¾è®¡è§„èŒƒï¼š

**v3.0 æ ¸å¿ƒä¼˜åŒ–**ï¼ˆ5 ä¸ªï¼‰ï¼š
1. âœ… `park()` è¿”è¿˜ `Piper<Standby>`ï¼Œæ”¯æŒçŠ¶æ€æµè½¬
2. âœ… ä½¿ç”¨ `spin_sleep` ä¿è¯å¾ªç¯ç²¾åº¦ï¼ˆ< 1ms æŠ–åŠ¨ï¼‰
3. âœ… Option æ¨¡å¼é¿å… `mem::forget`
4. âœ… æ˜ç¡® Cargo Workspace ç»“æ„
5. âœ… ä½¿ç”¨ `semver` è§£æå›ºä»¶ç‰ˆæœ¬

**v3.1 å·¥ç¨‹åŒ–å¢å¼º**ï¼ˆ3 ä¸ªï¼‰ï¼š
6. âœ… **å®¹é”™æ€§å¢å¼º**ï¼šæ§åˆ¶å¾ªç¯æ”¯æŒå¶å‘ä¸¢å¸§ï¼ˆè¿ç»­é”™è¯¯è®¡æ•°å™¨ï¼‰
7. âœ… **Token æ„é€ æ–¹å¼**ï¼šæä¾› `unsafe fn new_unchecked()` ä¾› GUI ä½¿ç”¨
8. âœ… **è½¯é™çº§ç­–ç•¥**ï¼šç‰ˆæœ¬è§£æå¤±è´¥æ—¶è­¦å‘Šä½†ä¸é˜»æ–­

**v3.2 ç‰©ç†ä¿®æ­£**ï¼ˆ1 ä¸ªï¼‰â­ï¼š
9. âœ… **å¾ªç¯é”šç‚¹ä¿®æ­£**ï¼šä½¿ç”¨ç»å¯¹æ—¶é—´é”šç‚¹æ¶ˆé™¤ç´¯ç§¯æ¼‚ç§»ï¼Œä¿è¯ç²¾ç¡® 200Hz æ§åˆ¶é¢‘ç‡

---

## ğŸš¨ å…³é”®ä¿®æ­£ï¼šå¾ªç¯æ¼‚ç§»é—®é¢˜ï¼ˆv3.2ï¼‰

### é—®é¢˜åˆ†æ

**v3.1 è®¾è®¡**ï¼š
```rust
let sleep_duration = Duration::from_secs_f64(1.0 / self.config.control_rate); // 5ms

while start.elapsed() < timeout {
    self.command_joints(target, None)?;  // å‡è®¾è€—æ—¶ 0.5ms
    // ...
    spin_sleep::sleep(sleep_duration);  // å›ºå®šç¡çœ  5ms
}
```

**é—®é¢˜**ï¼š
- âŒ å®é™…å¾ªç¯å‘¨æœŸ = `T_cmd + sleep_duration` = 0.5ms + 5ms = 5.5ms
- âŒ å®é™…æ§åˆ¶é¢‘ç‡ = 1000ms / 5.5ms â‰ˆ **181Hz**ï¼ˆè€Œéé¢„æœŸçš„ 200Hzï¼‰
- âŒ å¦‚æœ `T_cmd` æœ‰æ³¢åŠ¨ï¼Œæ§åˆ¶é¢‘ç‡ä¹Ÿä¼šéšä¹‹æ³¢åŠ¨

**æ ¹æœ¬åŸå› **ï¼š
1. **ç´¯ç§¯æ¼‚ç§»**ï¼šæ¯å‘¨æœŸå¤šå‡ºçš„ `T_cmd` æ—¶é—´ä¼šç´¯ç§¯
2. **é¢‘ç‡ä¸ç¨³å®š**ï¼šä¾èµ– CAN å‘é€è€—æ—¶ï¼Œå¯¼è‡´æ§åˆ¶é¢‘ç‡æ³¢åŠ¨

---

### ä¿®æ­£æ–¹æ¡ˆï¼šç»å¯¹æ—¶é—´é”šç‚¹

**v3.2 ä¿®æ­£**ï¼š
```rust
impl MitController {
    pub fn move_to_position(
        &mut self,
        target: [Rad; 6],
        threshold: Rad,
        timeout: Duration,
    ) -> Result<bool, ControlError> {
        const MAX_TOLERANCE: u32 = 5;
        let mut error_count = 0;

        let start = Instant::now();

        // âš ï¸ v3.2: ä½¿ç”¨ç»å¯¹æ—¶é—´é”šç‚¹
        let period = Duration::from_secs_f64(1.0 / self.config.control_rate);  // 5ms
        let mut next_tick = Instant::now();

        while start.elapsed() < timeout {
            // 1. è®¾å®šä¸‹ä¸€ä¸ªé”šç‚¹ï¼ˆç»å¯¹æ—¶é—´ï¼‰
            next_tick += period;

            // 2. å‘é€å‘½ä»¤ & æ£€æŸ¥çŠ¶æ€ï¼ˆè€—æ—¶æ“ä½œï¼‰
            match self.command_joints(target, None) {
                Ok(_) => error_count = 0,
                Err(e) => {
                    error_count += 1;
                    if error_count > MAX_TOLERANCE {
                        error!("Consecutive CAN failures: {}", error_count);
                        return Err(ControlError::ConsecutiveFailures {
                            count: error_count,
                            last_error: Box::new(e),
                        });
                    }
                    warn!("Transient CAN error: {}, skipping frame", e);
                    // è·³è¿‡æœ¬å¸§ï¼Œç»§ç»­å¾ªç¯
                    continue;
                }
            }

            // 3. æ£€æŸ¥æ˜¯å¦åˆ°è¾¾
            let current = self.observer.joint_positions();
            let reached = current.iter()
                .zip(target.iter())
                .all(|(c, t)| (c - t).abs() < threshold);

            if reached {
                return Ok(true);
            }

            // 4. âš ï¸ v3.2: ç¡çœ åˆ°ä¸‹ä¸€ä¸ªé”šç‚¹ï¼ˆè‡ªåŠ¨æ‰£é™¤è€—æ—¶æ“ä½œçš„æ—¶é—´ï¼‰
            let now = Instant::now();
            if next_tick > now {
                // è¿˜æœ‰å‰©ä½™æ—¶é—´ï¼Œç¡çœ åˆ°ä¸‹ä¸€ä¸ªé”šç‚¹
                spin_sleep::sleep(next_tick - now);
            } else {
                // âš ï¸ ä»»åŠ¡è¶…æ—¶ï¼ˆOverrunï¼‰ï¼šè€—æ—¶æ“ä½œè¶…è¿‡äº†é¢„æœŸå‘¨æœŸ
                warn!(
                    "Control loop overrun: operation took {:?}, \
                     but next tick was {:?} from now. \
                     Skipping sleep to catch up.",
                    now.elapsed_since(next_tick - period),
                    next_tick.duration_since(now)
                );
                // è¿½èµ¶é”šç‚¹ï¼šä¸ç¡çœ ï¼Œç›´æ¥è¿›å…¥ä¸‹ä¸€å¸§
                next_tick = now;  // é‡ç½®é”šç‚¹
            }
        }

        Ok(false)
    }
}
```

**æ”¶ç›Š**ï¼š
- âœ… æ— è®º `command_joints` è€—æ—¶å¤šå°‘ï¼ˆåªè¦ < periodï¼‰ï¼Œæ§åˆ¶é¢‘ç‡éƒ½èƒ½é”å®šåœ¨ 200Hz
- âœ… æ¶ˆé™¤ç´¯ç§¯æ¼‚ç§»ï¼Œæ§åˆ¶é¢‘ç‡ç²¾ç¡®ç¨³å®š
- âœ… è‡ªåŠ¨å¤„ç†è¶…æ—¶ï¼ˆOverrunï¼‰æƒ…å†µ
- âœ… æ”¯æŒä»»åŠ¡è€—æ—¶æ³¢åŠ¨ï¼ˆCAN å‘é€æœ‰ jitterï¼‰

---

## ä¼˜å…ˆçº§æ¸…å•

### ğŸ”´ æœ€é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰

| ç‰¹æ€§ | å·¥ä½œé‡ | ä»·å€¼æå‡ | å…³é”®ä¿®æ­£ |
|------|--------|----------|----------|
| **MitController** | 2-3 å¤© | â­â­â­â­â­ | âš ï¸ v3.2 å¾ªç¯é”šç‚¹ä¿®æ­£ |
| **å¥å£® reset é€»è¾‘** | 1 å¤© | â­â­â­â­â­ | è‡ªåŠ¨é‡è¯• + è¶…æ—¶ |
| **show_status() è¯Šæ–­** | 1 å¤© | â­â­â­â­ | äººç±»å¯è¯» + é”™è¯¯è§£æ |
| **ç¢°æ’ä¿æŠ¤ API** | 0.5 å¤© | â­â­â­â­ | çº§åˆ« 0-8 |
| **å…³èŠ‚å½’é›¶** | 0.5 å¤© | â­â­â­â­ | GUI å‹å¥½ |

**æ€»å·¥ä½œé‡**: ~5-6 å¤©
**å®æ–½é¡ºåº**: æŒ‰ä¸Šè¿°é¡ºåº

---

## è¯¦ç»†å®æ–½å»ºè®®

### 1. MitController é«˜å±‚æ§åˆ¶å™¨ï¼ˆâš ï¸ v3.2 æœ€ç»ˆä¿®æ­£ç‰ˆï¼‰

**ç›®æ ‡**: ç®€åŒ– MIT æ¨¡å¼çš„ä½¿ç”¨ï¼Œå®Œç¾å¥‘åˆ Type State Patternï¼Œå…·å¤‡ç”Ÿäº§çº§å¥å£®æ€§ï¼Œå¹¶ä¿è¯ç²¾ç¡®æ§åˆ¶é¢‘ç‡ã€‚

#### âš ï¸ å…³é”®ä¼˜åŒ– 1ï¼šçŠ¶æ€æµè½¬

**è®¾è®¡**ï¼ˆä¸ v3.1 ç›¸åŒï¼‰ï¼š
```rust
pub fn park(mut self) -> Result<Piper<Standby>, Error> {
    let mut piper = self.piper.take().expect("Piper should exist");
    let piper_standby = piper.into_standby()?;
    Ok(piper_standby)
}
```

---

#### âš ï¸ å…³é”®ä¼˜åŒ– 2ï¼šå¾ªç¯é”šç‚¹ä¿®æ­£ï¼ˆv3.2 æ–°å¢ï¼‰â­

**å®Œæ•´å®ç°ä»£ç **ï¼š

```rust
impl MitController {
    /// é˜»å¡å¼è¿åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆå¸¦å®¹é”™æ€§ + å¾ªç¯é”šç‚¹ï¼‰
    ///
    /// # å®¹é”™æ€§
    ///
    /// æ§åˆ¶å¾ªç¯å…·æœ‰**å®¹é”™æ€§**ï¼šå…è®¸å¶å°”çš„ CAN é€šä¿¡é”™è¯¯ï¼ˆæœ€å¤šè¿ç»­ 5 å¸§ï¼‰ã€‚
    ///
    /// # æ§åˆ¶é¢‘ç‡ç²¾åº¦ âš ï¸ v3.2
    ///
    /// ä½¿ç”¨**ç»å¯¹æ—¶é—´é”šç‚¹**æœºåˆ¶ï¼Œæ¶ˆé™¤ç´¯ç§¯æ¼‚ç§»ï¼Œä¿è¯ç²¾ç¡®çš„ 200Hz æ§åˆ¶é¢‘ç‡ï¼š
    /// - æ— è®º CAN é€šä¿¡è€—æ—¶å¤šå°‘ï¼ˆåªè¦ < 5msï¼‰ï¼Œæ§åˆ¶é¢‘ç‡éƒ½é”å®šåœ¨ 200Hz
    /// - è‡ªåŠ¨å¤„ç†ä»»åŠ¡è¶…æ—¶ï¼ˆOverrunï¼‰æƒ…å†µ
    /// - æ”¯æŒä»»åŠ¡è€—æ—¶æ³¢åŠ¨ï¼ˆjitterï¼‰
    ///
    /// # å‚æ•°
    ///
    /// - `target`: ç›®æ ‡å…³èŠ‚ä½ç½®ï¼ˆå¼§åº¦ï¼‰
    /// - `threshold`: åˆ°è¾¾é˜ˆå€¼ï¼ˆå¼§åº¦ï¼‰
    /// - `timeout`: è¶…æ—¶æ—¶é—´
    ///
    /// # è¿”å›
    ///
    /// - `Ok(true)`: åˆ°è¾¾ç›®æ ‡
    /// - `Ok(false)`: è¶…æ—¶æœªåˆ°è¾¾
    /// - `Err(ControlError::ConsecutiveFailures)`: è¿ç»­é”™è¯¯è¶…è¿‡é˜ˆå€¼
    ///
    /// # ç¤ºä¾‹
    ///
    /// ```rust
    /// let mut controller = MitController::new(piper, config)?;
    ///
    /// controller.move_to_position(
    ///     [Rad(0.5), Rad(0.7), Rad(-0.4), Rad(0.2), Rad(0.3), Rad(0.5)],
    ///     Rad(0.01),
    ///     Duration::from_secs(5.0),
    /// )?;
    /// ```
    pub fn move_to_position(
        &mut self,
        target: [Rad; 6],
        threshold: Rad,
        timeout: Duration,
    ) -> Result<bool, ControlError> {
        const MAX_TOLERANCE: u32 = 5;  // å…è®¸è¿ç»­ä¸¢ 5 å¸§ï¼ˆ25ms @ 200Hzï¼‰
        let mut error_count = 0;

        let start = Instant::now();

        // âš ï¸ v3.2: ä½¿ç”¨ç»å¯¹æ—¶é—´é”šç‚¹ï¼Œæ¶ˆé™¤å¾ªç¯æ¼‚ç§»
        let period = Duration::from_secs_f64(1.0 / self.config.control_rate);  // 5ms @ 200Hz
        let mut next_tick = Instant::now();

        while start.elapsed() < timeout {
            // 1. è®¾å®šä¸‹ä¸€ä¸ªé”šç‚¹ï¼ˆç»å¯¹æ—¶é—´ï¼‰
            next_tick += period;

            // 2. å‘é€å‘½ä»¤ & æ£€æŸ¥çŠ¶æ€ï¼ˆè€—æ—¶æ“ä½œï¼‰
            match self.command_joints(target, None) {
                Ok(_) => {
                    error_count = 0;  // é‡ç½®è®¡æ•°å™¨
                }
                Err(e) => {
                    error_count += 1;
                    if error_count > MAX_TOLERANCE {
                        error!(
                            "Consecutive CAN failures ({}): {:?}. Aborting motion.",
                            error_count, e
                        );
                        return Err(ControlError::ConsecutiveFailures {
                            count: error_count,
                            last_error: Box::new(e),
                        });
                    }
                    warn!(
                        "Transient CAN error ({}): {:?}, skipping frame. \
                         This is acceptable as long as errors don't occur consecutively.",
                        error_count, e
                    );
                    // è·³è¿‡æœ¬å¸§ï¼Œç»§ç»­å¾ªç¯
                    continue;
                }
            }

            // 3. æ£€æŸ¥æ˜¯å¦åˆ°è¾¾
            let current = self.observer.joint_positions();
            let reached = current.iter()
                .zip(target.iter())
                .all(|(c, t)| (c - t).abs() < threshold);

            if reached {
                return Ok(true);
            }

            // 4. âš ï¸ v3.2: ç¡çœ åˆ°ä¸‹ä¸€ä¸ªé”šç‚¹ï¼ˆè‡ªåŠ¨æ‰£é™¤è€—æ—¶æ“ä½œçš„æ—¶é—´ï¼‰
            let now = Instant::now();
            if next_tick > now {
                // è¿˜æœ‰å‰©ä½™æ—¶é—´ï¼Œç¡çœ åˆ°ä¸‹ä¸€ä¸ªé”šç‚¹
                spin_sleep::sleep(next_tick - now);
            } else {
                // âš ï¸ ä»»åŠ¡è¶…æ—¶ï¼ˆOverrunï¼‰ï¼šè€—æ—¶æ“ä½œè¶…è¿‡äº†é¢„æœŸå‘¨æœŸ
                warn!(
                    "Control loop overrun: operation took {:?}, \
                     but next tick was {:?} from now (expected {:?}). \
                     Skipping sleep to catch up.",
                    now.duration_since(next_tick - period),
                    next_tick.duration_since(now),
                    period
                );
                // è¿½èµ¶é”šç‚¹ï¼šä¸ç¡çœ ï¼Œç›´æ¥è¿›å…¥ä¸‹ä¸€å¸§
                // é‡ç½®é”šç‚¹åˆ°å½“å‰æ—¶é—´ï¼Œé¿å…åç»­ç´¯ç§¯å»¶è¿Ÿ
                next_tick = now;
            }
        }

        Ok(false)
    }
}
```

**æŠ€æœ¯åŸç†**ï¼š

```
v3.1 (æœ‰æ¼‚ç§»):
Frame 0:  0ms (start) â†’ cmd 0.5ms â†’ sleep 5ms â†’ 5.5ms (å®é™…)
Frame 1:  5.5ms â†’ cmd 0.5ms â†’ sleep 5ms â†’ 11.0ms (å®é™…)
Frame 2:  11.0ms â†’ cmd 0.5ms â†’ sleep 5ms â†’ 16.5ms (å®é™…)
â†’ é¢‘ç‡: 1000ms / 5.5ms â‰ˆ 181Hz âŒ

v3.2 (é”šç‚¹ä¿®æ­£):
Frame 0:  0ms â†’ cmd 0.5ms â†’ sleep 4.5ms â†’ 5ms (é”šç‚¹)
Frame 1:  5ms â†’ cmd 0.5ms â†’ sleep 4.5ms â†’ 10ms (é”šç‚¹)
Frame 2:  10ms â†’ cmd 0.5ms â†’ sleep 4.5ms â†’ 15ms (é”šç‚¹)
â†’ é¢‘ç‡: 1000ms / 5ms = 200Hz âœ… (ç¨³å®š)
```

**å…³é”®æ”¶ç›Š**ï¼š
1. âœ… **ç²¾ç¡®é¢‘ç‡**ï¼šæ— è®º CAN è€—æ—¶å¤šå°‘ï¼ˆåªè¦ < 5msï¼‰ï¼Œé¢‘ç‡éƒ½é”å®šåœ¨ 200Hz
2. âœ… **æ¶ˆé™¤æ¼‚ç§»**ï¼šä¸ç´¯ç§¯æ—¶é—´è¯¯å·®
3. âœ… **å¤„ç†è¶…æ—¶**ï¼šè‡ªåŠ¨æ£€æµ‹å¹¶å¤„ç† overrun æƒ…å†µ
4. âœ… **ç¨³å®šæ€§**ï¼šå³ä½¿ CAN é€šä¿¡æœ‰ jitterï¼Œæ§åˆ¶é¢‘ç‡ä»ç„¶ç¨³å®š

---

#### âš ï¸ å…³é”®ä¼˜åŒ– 3-8

ï¼ˆä¸ v3.1 ç›¸åŒï¼Œç•¥ï¼‰
- èµ„æºç®¡ç†ä¼˜åŒ–ï¼ˆOption æ¨¡å¼ï¼‰
- å¾ªç¯ç²¾åº¦ä¼˜åŒ–ï¼ˆspin_sleepï¼‰
- Token æ„é€ æ–¹å¼ï¼ˆunsafe fn new_uncheckedï¼‰
- è½¯é™çº§ç­–ç•¥ï¼ˆsemverï¼‰

---

## ä½¿ç”¨ç¤ºä¾‹ï¼ˆv3.2ï¼‰

### ç¤ºä¾‹ 1ï¼šåŸºæœ¬ä½¿ç”¨ï¼ˆå±•ç¤ºç²¾ç¡®é¢‘ç‡ï¼‰

```rust
use piper_sdk::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let piper = PiperBuilder::new()?
        .connect("can0")?
        .enable(MitMode::default(), EnableConfig::default())?;

    let config = MitControllerConfig {
        // âš ï¸ ç±»å‹è¯´æ˜ï¼škp/kd å¢ç›Šä½¿ç”¨ f64 ç±»å‹ï¼ˆå•ä½ï¼šNm/rad å’Œ Nm/(rad/s)ï¼‰
        // æ–‡æ¡£ä¸­ä½¿ç”¨ RadPerSec å’Œ NewtonMeterPerRadPerSec æ˜¯ä¸ºäº†è¯´æ˜å•ä½å«ä¹‰
        // å®é™…å®ç°ä¸­ä½¿ç”¨ f64 ä»¥ç®€åŒ–ç±»å‹ç³»ç»Ÿ
        kp_gains: [5.0; 6],      // å•ä½ï¼šNm/rad
        kd_gains: [0.8; 6],      // å•ä½ï¼šNm/(rad/s)
        rest_position: Some(ArmOrientations::UPRIGHT.rest_position),
        control_rate: 200.0,  // âš ï¸ ç²¾ç¡® 200Hz
    };

    let mut controller = MitController::new(piper, config)?;

    // âš ï¸ v3.2: é”šç‚¹ä¿®æ­£ï¼Œä¿è¯ç²¾ç¡® 200Hzï¼ˆæ— è®º CAN è€—æ—¶ï¼‰
    let target = [
        Rad(0.5), Rad(0.7), Rad(-0.4),
        Rad(0.2), Rad(0.3), Rad(0.5),
    ];

    match controller.move_to_position(
        target,
        Rad(0.01),
        Duration::from_secs(5.0),
    )? {
        true => println!("âœ… Reached target at 200Hz"),
        false => println!("â±ï¸  Timeout (but close)"),
    }

    // âš ï¸ æ˜¾å¼åœè½¦
    let piper_standby = controller.park()?;

    Ok(())
}
```

---

## å…³é”®è®¾è®¡åŸåˆ™æ€»ç»“ï¼ˆv3.2ï¼‰

### 1. çŠ¶æ€æµè½¬ä¼˜äºæ¶ˆè€—
```rust
// âœ… v3.2: è¿”è¿˜æ‰€æœ‰æƒ
let piper_standby = controller.park()?;
```

### 2. é«˜ç²¾åº¦å¾ªç¯ä¼˜äºå›ºå®šå»¶è¿Ÿ
```rust
// âœ… v3.2: é”šç‚¹æœºåˆ¶ï¼ˆæ¶ˆé™¤æ¼‚ç§»ï¼‰
let mut next_tick = Instant::now();
next_tick += period;  // è®¾å®šä¸‹ä¸€ä¸ªé”šç‚¹

// æ‰§è¡Œè€—æ—¶æ“ä½œ...

// ç¡çœ åˆ°é”šç‚¹ï¼ˆè‡ªåŠ¨æ‰£é™¤è€—æ—¶ï¼‰
if next_tick > Instant::now() {
    spin_sleep::sleep(next_tick - Instant::now());
}

// âŒ v3.1: å›ºå®šå»¶è¿Ÿï¼ˆæœ‰æ¼‚ç§»ï¼‰
spin_sleep::sleep(Duration::from_secs_f64(1.0 / 200.0));  // ç´¯ç§¯è¯¯å·®
```

### 3. å®¹é”™æ€§ä¼˜äº Fail-Fast
```rust
// âœ… v3.1/v3.2: å®¹è®¸å¶å‘ä¸¢å¸§
const MAX_TOLERANCE: u32 = 5;
```

### 4. Option æ¨¡å¼ä¼˜äº forget
```rust
// âœ… v3.1/v3.2: Option å…è®¸å®‰å…¨æå–
let piper = self.piper.take()?;
```

---

## å®æ–½æ£€æŸ¥æ¸…å•ï¼ˆv3.2ï¼‰

### Phase 1: æ ¸å¿ƒå¯é æ€§ï¼ˆWeek 1-2ï¼‰

- [ ] **MitController å®ç°** âš ï¸ **v3.2 æœ€ç»ˆä¿®æ­£**
  - [ ] åŸºç¡€ç»“æ„ä½“ï¼ˆOption<Piper>ï¼‰
  - [ ] `move_to_position()`ï¼ˆâš ï¸ v3.2: å¾ªç¯é”šç‚¹ä¿®æ­£ï¼‰
  - [ ] `park()`ï¼ˆè¿”è¿˜ Piper<Standby>ï¼‰
  - [ ] `relax_joints()`ï¼ˆè½¯é™çº§ï¼‰
  - [ ] `Drop`ï¼ˆOption æ¨¡å¼ï¼‰
  - [ ] å•å…ƒæµ‹è¯•ï¼ˆâš ï¿½ï¸ åŒ…å«é¢‘ç‡æµ‹è¯•ï¼‰

- [ ] **ZeroingConfirmToken**
  - [ ] `confirm_from_env()`
  - [ ] `unsafe fn new_unchecked()`
  - [ ] `confirm_for_test()`

- [ ] Workspace é…ç½®
- [ ] å…¶ä»–åŠŸèƒ½

**æ€»è®¡**: ~6 å¤©

---

## æµ‹è¯•å¢å¼ºï¼ˆv3.2ï¼‰

### é¢‘ç‡æµ‹è¯•

```rust
#[test]
#[ignore = "requires hardware"]
fn test_control_frequency() {
    let piper = enable_robot()?;
    let config = MitControllerConfig {
        control_rate: 200.0,
        ..Default::default()
    };
    let mut controller = MitController::new(piper, config)?;

    let start = Instant::now();
    let mut frames = 0;

    // è¿è¡Œ 1 ç§’é’Ÿ
    while start.elapsed() < Duration::from_secs(1) {
        controller.command_joints(target, None)?;
        frames += 1;
        spin_sleep::sleep(Duration::from_secs_f64(1.0 / 200.0));
    }

    let elapsed = start.elapsed();
    let actual_freq = frames as f64 / elapsed.as_secs_f64();

    // âš ï¸ v3.2: éªŒè¯é¢‘ç‡ç²¾ç¡®æ€§
    assert!((actual_freq - 200.0).abs() < 1.0, "Frequency drift: {} Hz", actual_freq);
}
```

---

## æ–‡æ¡£ç‰ˆæœ¬å†å²

- **v3.0**: 5 ä¸ªå…³é”®ä¼˜åŒ–ï¼ˆçŠ¶æ€æµè½¬ã€ç²¾åº¦ã€èµ„æºç®¡ç†ã€é¡¹ç›®ç»“æ„ã€ç‰ˆæœ¬è§£æï¼‰
- **v3.1**: 3 ä¸ªå·¥ç¨‹åŒ–å¢å¼ºï¼ˆå®¹é”™æ€§ã€Token æ„é€ ã€è½¯é™çº§ï¼‰
- **v3.2**: 1 ä¸ªç‰©ç†ä¿®æ­£ï¼ˆå¾ªç¯é”šç‚¹ï¼‰â­â­â­ **æ¶ˆé™¤é¢‘ç‡æ¼‚ç§»**

---

## æœ€ç»ˆè¯„å®¡ç»“è®º

âœ… **æ¶æ„å®Œç¾ï¼Œå‡†å¤‡å®æ–½**

**v3.2 çš„å…¨éƒ¨ 9 ä¸ªä¼˜åŒ–**ï¼š
1. âœ… çŠ¶æ€æµè½¬ä¼˜åŒ–
2. âœ… å¾ªç¯ç²¾åº¦ä¼˜åŒ–ï¼ˆspin_sleepï¼‰
3. âœ… èµ„æºç®¡ç†ä¼˜åŒ–ï¼ˆOption æ¨¡å¼ï¼‰
4. âœ… é¡¹ç›®ç»“æ„ä¼˜åŒ–ï¼ˆWorkspaceï¼‰
5. âœ… ç‰ˆæœ¬è§£æä¼˜åŒ–ï¼ˆsemverï¼‰
6. âœ… å®¹é”™æ€§å¢å¼º
7. âœ… Token æ„é€ æ–¹å¼
8. âœ… è½¯é™çº§ç­–ç•¥
9. âœ… **å¾ªç¯é”šç‚¹ä¿®æ­£**ï¼ˆæ¶ˆé™¤é¢‘ç‡æ¼‚ç§»ï¼‰â­ v3.2

**ç‰©ç†æ­£ç¡®æ€§**ï¼š
- ğŸ¯ æ§åˆ¶é¢‘ç‡ï¼šç²¾ç¡® 200Hzï¼ˆÂ±1Hzï¼‰
- ğŸ›¡ï¸ å®¹é”™æ€§ï¼šå…è®¸å¶å‘ä¸¢å¸§ï¼ˆæœ€å¤š 5 å¸§ï¼‰
- ğŸ”§ å…¼å®¹æ€§ï¼šæ”¯æŒéæ ‡å‡†ç‰ˆæœ¬å·
- ğŸ¯ GUI å‹å¥½ï¼šå¤šç§ç¡®è®¤æ–¹å¼

---

**æ–‡æ¡£ç‰ˆæœ¬**: 3.2 (æœ€ç»ˆä¿®æ­£ç‰ˆ)
**æœ€åæ›´æ–°**: 2026-01-26
**ä½œè€…**: Claude (Anthropic)
**çŠ¶æ€**: â­â­â­ ç”Ÿäº§å°±ç»ªï¼ˆæ¶æ„å†»ç»“ï¼Œå‡†å¤‡å®æ–½ï¼‰
