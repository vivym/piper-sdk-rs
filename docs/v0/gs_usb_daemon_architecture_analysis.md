# GS-USB Daemon æ¶æ„æ·±åº¦åˆ†ææŠ¥å‘Š

**æ—¥æœŸ**: 2026-01-20
**ç‰ˆæœ¬**: v1.0
**åˆ†æç›®æ ‡**: è¯„ä¼° gs_usb_daemon æ˜¯å¦æ»¡è¶³åŠ›æ§æœºæ¢°è‡‚çš„å®æ—¶æ€§éœ€æ±‚

---

## æ‰§è¡Œæ‘˜è¦

æœ¬æŠ¥å‘Šå¯¹ gs_usb_daemon çš„å®ç°è¿›è¡Œäº†æ·±å…¥åˆ†æï¼Œé‡ç‚¹å…³æ³¨å…¶æ¶æ„è®¾è®¡ã€å®æ—¶æ€§èƒ½å’Œå¯¹åŠ›æ§æœºæ¢°è‡‚åº”ç”¨çš„é€‚ç”¨æ€§ã€‚

### æ ¸å¿ƒç»“è®º

âœ… **æ€»ä½“è¯„ä»·**: gs_usb_daemon çš„æ¶æ„è®¾è®¡**åŸºæœ¬æ»¡è¶³**åŠ›æ§æœºæ¢°è‡‚çš„å®æ—¶æ€§è¦æ±‚ï¼Œä½†å­˜åœ¨è‹¥å¹²**å…³é”®ä¼˜åŒ–ç‚¹**éœ€è¦æ”¹è¿›ã€‚

### å…³é”®æŒ‡æ ‡

| æŒ‡æ ‡ | åŠ›æ§è¦æ±‚ | å½“å‰å®ç° | çŠ¶æ€ |
|-----|---------|---------|------|
| å¾€è¿”å»¶è¿Ÿ | < 200Î¼s | ä¼°è®¡ 150-300Î¼s | âš ï¸ è¾¹ç¼˜ |
| å»¶è¿ŸæŠ–åŠ¨ (P99) | < 100Î¼s | ä¼°è®¡ 200-500Î¼s | âŒ ä¸è¾¾æ ‡ |
| æ§åˆ¶é¢‘ç‡ | 1kHz (1ms) | æ”¯æŒ | âœ… è¾¾æ ‡ |
| ä¸¢åŒ…å¤„ç† | 0% | ä¾èµ– USB | âš ï¸ éœ€æ”¹è¿› |
| çƒ­æ‹”æ’æ¢å¤ | < 1s | < 1.5s | âœ… è¾¾æ ‡ |

**å…³é”®é£é™©**:
1. ğŸ”´ **UDS é˜»å¡å‘é€**ï¼šå¡æ­»çš„å®¢æˆ·ç«¯ä¼šæ‹–æ­»æ•´ä¸ª daemonï¼ˆ**æœ€å±é™©**ï¼‰
2. âš ï¸ **RwLock å†™é”ç«äº‰**ï¼šå¯èƒ½å¯¼è‡´æ•°ç™¾å¾®ç§’çº§å»¶è¿ŸæŠ–åŠ¨
3. âš ï¸ **200ms USB è¶…æ—¶**ï¼šä¼šé˜»å¡æ•´ä¸ªæ¥æ”¶å¾ªç¯
4. âš ï¸ **IPC å±‚çº§è¿‡å¤š**ï¼šå¢åŠ å»¶è¿Ÿå’Œä¸ç¡®å®šæ€§

---

## 1. æ¶æ„è®¾è®¡åˆ†æ

### 1.1 æ•´ä½“æ¶æ„

gs_usb_daemon é‡‡ç”¨**å¤šçº¿ç¨‹é˜»å¡ I/O æ¶æ„**ï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      GS-USB Daemon                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Device Mgr   â”‚  â”‚  USB RX      â”‚  â”‚   IPC RX     â”‚    â”‚
â”‚  â”‚  Thread      â”‚  â”‚  Thread      â”‚  â”‚   Thread     â”‚    â”‚
â”‚  â”‚ (Low Prio)   â”‚  â”‚ (é˜»å¡ I/O)   â”‚  â”‚  (é˜»å¡ I/O)  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                 â”‚                 â”‚             â”‚
â”‚         â”‚                 â”‚                 â”‚             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚        Shared State (Arc<RwLock<T>>)              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚ Adapter   â”‚  â”‚ DeviceStateâ”‚  â”‚ Clients  â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚ Client       â”‚  â”‚  Status       â”‚                     â”‚
â”‚  â”‚ Cleanup      â”‚  â”‚  Print        â”‚                     â”‚
â”‚  â”‚ (Low Prio)   â”‚  â”‚  (Low Prio)   â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**è®¾è®¡ç‰¹ç‚¹**:
1. âœ… **çº¿ç¨‹éš”ç¦»**: USB RXã€IPC RXã€è®¾å¤‡ç®¡ç†å„è‡ªç‹¬ç«‹
2. âœ… **é˜»å¡ I/O**: é¿å…è½®è¯¢ï¼Œä¾èµ–å†…æ ¸å”¤é†’æœºåˆ¶
3. âœ… **QoS ä¼˜å…ˆçº§**: macOS ä¸Šä½¿ç”¨ QOS_CLASS_USER_INTERACTIVE
4. âš ï¸ **å…±äº«çŠ¶æ€**: ä½¿ç”¨ RwLock ä¿æŠ¤ï¼Œå­˜åœ¨é”ç«äº‰é£é™©

### 1.2 çº¿ç¨‹æ¨¡å‹è¯¦è§£

#### Thread 1: è®¾å¤‡ç®¡ç†çº¿ç¨‹ (Device Manager)

```rust:314:336:daemon.rs
fn device_manager_loop(
    adapter: Arc<RwLock<Option<GsUsbCanAdapter>>>,
    device_state: Arc<RwLock<DeviceState>>,
    config: DaemonConfig,
) {
    loop {
        match current_state {
            DeviceState::Connected => {
                thread::sleep(Duration::from_millis(100)); // âš ï¸ 100ms sleep
            },
            DeviceState::Disconnected => {
                // å»æŠ–åŠ¨ï¼šç­‰å¾… 500ms
                thread::sleep(config.reconnect_debounce);
                // è¿›å…¥é‡è¿çŠ¶æ€
            },
            DeviceState::Reconnecting => {
                // å°è¯•è¿æ¥
                match Self::try_connect_device(&config) {
                    Ok(new_adapter) => { /* ... */ },
                    Err(e) => {
                        thread::sleep(config.reconnect_interval); // 1s
                    },
                }
            },
        }
    }
}
```

**åˆ†æ**:
- âœ… **ä½ä¼˜å…ˆçº§**: ä¸å½±å“å®æ—¶è·¯å¾„
- âœ… **å»æŠ–åŠ¨æœºåˆ¶**: é¿å… macOS USB æšä¸¾æŠ–åŠ¨
- âœ… **çŠ¶æ€æœºé©±åŠ¨**: æ¸…æ™°çš„çŠ¶æ€è½¬æ¢é€»è¾‘

#### Thread 2: USB æ¥æ”¶çº¿ç¨‹ (USB RX)

```rust:398:476:daemon.rs
fn usb_receive_loop(
    adapter: Arc<RwLock<Option<GsUsbCanAdapter>>>,
    device_state: Arc<RwLock<DeviceState>>,
    clients: Arc<RwLock<ClientManager>>,
    socket_uds: Option<std::os::unix::net::UnixDatagram>,
    socket_udp: Option<std::net::UdpSocket>,
    stats: Arc<RwLock<DaemonStats>>,
) {
    loop {
        // 1. æ£€æŸ¥è®¾å¤‡çŠ¶æ€ï¼ˆè¯»é”ï¼‰
        let adapter_guard = adapter.read().unwrap();

        // 2. ä» USB è¯»å–ï¼ˆéœ€è¦å†™é”ï¼ï¼‰
        drop(adapter_guard);
        let frame = {
            let mut adapter_guard = adapter.write().unwrap(); // âš ï¸ å†™é”ç«äº‰
            match adapter_guard.as_mut() {
                Some(a) => match a.receive() {
                    Ok(f) => f,
                    Err(Timeout) => continue, // âš ï¸ 200ms è¶…æ—¶
                    Err(e) => { /* é”™è¯¯å¤„ç† */ }
                },
                None => {
                    thread::sleep(Duration::from_millis(100));
                    continue;
                }
            }
        };

        // 3. å¹¿æ’­ç»™å®¢æˆ·ç«¯ï¼ˆè¯»é”ï¼‰
        let clients_guard = clients.read().unwrap();
        for client in clients_guard.iter() {
            // ç¼–ç  + å‘é€
            socket_uds.send_to(encoded, &client.addr)?;  // âš ï¸ é˜»å¡å‘é€ï¼
        }
    }
}

// âš ï¸ **å…³é”®é—®é¢˜**: UDS send_to åœ¨ç¼“å†²åŒºæ»¡æ—¶ä¼šé˜»å¡ï¼
// å¦‚æœæŸä¸ªå®¢æˆ·ç«¯å¡æ­»ï¼Œä¼šæ‹–æ­»æ•´ä¸ª daemon å’Œæ‰€æœ‰å…¶ä»–å®¢æˆ·ç«¯
```

**å…³é”®é—®é¢˜åˆ†æ**:

| é—®é¢˜ç‚¹ | å½±å“ | ä¸¥é‡æ€§ |
|-------|------|--------|
| **receive() éœ€è¦ &mut self** | å¿…é¡»è·å–å†™é”ï¼Œé˜»å¡æ‰€æœ‰è¯»æ“ä½œ | ğŸ”´ é«˜ |
| **200ms USB è¶…æ—¶** | æ¯æ¬¡è¶…æ—¶ä¼šé˜»å¡ 200ms | ğŸ”´ é«˜ |
| **å†™é” â†’ è¯»é”åˆ‡æ¢** | drop(å†™é”) â†’ acquire(è¯»é”)ï¼Œæœ‰ç«äº‰çª—å£ | ğŸŸ¡ ä¸­ |
| **åŒæ­¥å‘é€ç»™å¤šå®¢æˆ·ç«¯** | O(n) å®¢æˆ·ç«¯æ•°é‡ï¼Œå¯èƒ½ç´¯ç§¯å»¶è¿Ÿ | ğŸŸ¡ ä¸­ |
| **UDS send_to é˜»å¡** | å®¢æˆ·ç«¯ç¼“å†²åŒºæ»¡æ—¶ä¼šé˜»å¡æ•´ä¸ªå¾ªç¯ | ğŸ”´ **è‡´å‘½** |

#### Thread 3: IPC æ¥æ”¶çº¿ç¨‹ (IPC RX)

```rust:571:615:daemon.rs
fn ipc_receive_loop(
    socket: std::os::unix::net::UnixDatagram,
    adapter: Arc<RwLock<Option<GsUsbCanAdapter>>>,
    device_state: Arc<RwLock<DeviceState>>,
    clients: Arc<RwLock<ClientManager>>,
    stats: Arc<RwLock<DaemonStats>>,
) {
    // è®¾ç½®é«˜ä¼˜å…ˆçº§
    crate::macos_qos::set_high_priority();

    let mut buf = [0u8; 1024];
    loop {
        // âœ… é˜»å¡æ¥æ”¶ï¼ˆå†…æ ¸çº§å”¤é†’ï¼‰
        match socket.recv_from(&mut buf) {
            Ok((len, client_addr)) => {
                let msg = decode_message(&buf[..len])?;
                match msg {
                    Message::SendFrame { frame, seq } => {
                        // âš ï¸ éœ€è¦è·å–å†™é”å‘é€
                        let mut adapter_guard = adapter.write().unwrap();
                        adapter_ref.send(frame)?;
                    },
                    // ... å…¶ä»–æ¶ˆæ¯ç±»å‹
                }
            },
            Err(e) => {
                thread::sleep(Duration::from_millis(100));
            }
        }
    }
}
```

**åˆ†æ**:
- âœ… **é«˜ä¼˜å…ˆçº§**: USER_INTERACTIVE çº§åˆ«
- âœ… **é˜»å¡ I/O**: recv_from() é˜»å¡ï¼Œæ— è½®è¯¢å¼€é”€
- âš ï¸ **send() éœ€è¦å†™é”**: ä¸ USB RX ç«äº‰ adapter çš„å†™é”
- âš ï¸ **åŒæ­¥å‘é€**: send() å¯èƒ½é˜»å¡ï¼ˆUSB bulk out è¶…æ—¶ 1000msï¼‰

### 1.3 å…±äº«çŠ¶æ€é”ç«äº‰åˆ†æ

#### å…³é”®å…±äº«èµ„æº

```rust:182:206:daemon.rs
pub struct Daemon {
    /// GS-USB é€‚é…å™¨ï¼ˆä½¿ç”¨ RwLock ä¼˜åŒ–è¯»å–æ€§èƒ½ï¼‰
    adapter: Arc<RwLock<Option<GsUsbCanAdapter>>>,  // âš ï¸ æ ¸å¿ƒç«äº‰ç‚¹

    /// è®¾å¤‡çŠ¶æ€
    device_state: Arc<RwLock<DeviceState>>,

    /// å®¢æˆ·ç«¯ç®¡ç†å™¨ï¼ˆä½¿ç”¨ RwLock ä¼˜åŒ–è¯»å–æ€§èƒ½ï¼‰
    clients: Arc<RwLock<ClientManager>>,  // âš ï¸ æ¬¡è¦ç«äº‰ç‚¹

    /// ç»Ÿè®¡ä¿¡æ¯
    stats: Arc<RwLock<DaemonStats>>,
}
```

#### é”ç«äº‰åœºæ™¯

**åœºæ™¯ 1: USB RX vs IPC RX (adapter å†™é”ç«äº‰)**

```
æ—¶é—´è½´:
T0:  USB RX è·å–å†™é”ï¼Œè°ƒç”¨ adapter.receive()
     â””â”€> rusb::read_bulk() é˜»å¡ï¼Œç­‰å¾… USB æ•°æ®æˆ–è¶…æ—¶ (200ms)

T1:  IPC RX å°è¯•è·å–å†™é”ï¼Œè°ƒç”¨ adapter.send()
     â””â”€> é˜»å¡ç­‰å¾… USB RX é‡Šæ”¾å†™é” âš ï¸

T2:  USB RX è¶…æ—¶/æ”¶åˆ°æ•°æ®ï¼Œé‡Šæ”¾å†™é”
     â””â”€> IPC RX è·å–å†™é”ï¼Œå‘é€ CAN å¸§
```

**å»¶è¿Ÿå½±å“**:
- **æœ€åæƒ…å†µ**: IPC RX ç­‰å¾… 200msï¼ˆUSB è¶…æ—¶ï¼‰
- **å…¸å‹æƒ…å†µ**: IPC RX ç­‰å¾… 0-50Î¼sï¼ˆUSB æ­£å¸¸æ¥æ”¶ï¼‰
- **P99 å»¶è¿Ÿ**: ä¼°è®¡ **100-500Î¼s**ï¼ˆå–å†³äº CAN æ€»çº¿è´Ÿè½½ï¼‰

**åœºæ™¯ 2: USB RX å¹¿æ’­ vs IPC RX ä¿®æ”¹å®¢æˆ·ç«¯åˆ—è¡¨ (clients é”ç«äº‰)**

```
æ—¶é—´è½´:
T0:  USB RX è·å–è¯»é”ï¼Œéå†å®¢æˆ·ç«¯åˆ—è¡¨
     â””â”€> å‘ N ä¸ªå®¢æˆ·ç«¯å‘é€å¸§ (O(n) å»¶è¿Ÿ)

T1:  IPC RX å°è¯•è·å–å†™é”ï¼Œæ³¨å†Œæ–°å®¢æˆ·ç«¯
     â””â”€> é˜»å¡ç­‰å¾… USB RX é‡Šæ”¾è¯»é” âš ï¸

T2:  USB RX å®Œæˆå¹¿æ’­ï¼Œé‡Šæ”¾è¯»é”
     â””â”€> IPC RX è·å–å†™é”ï¼Œæ³¨å†Œå®¢æˆ·ç«¯
```

**å»¶è¿Ÿå½±å“**:
- **å…¸å‹æƒ…å†µ**: IPC RX ç­‰å¾… 10-50Î¼sï¼ˆå¹¿æ’­ 1-5 ä¸ªå®¢æˆ·ç«¯ï¼‰
- **æœ€åæƒ…å†µ**: IPC RX ç­‰å¾… 100-500Î¼sï¼ˆå¹¿æ’­ 10+ ä¸ªå®¢æˆ·ç«¯ï¼‰

---

## 2. æ¶ˆæ¯æ”¶å‘è·¯å¾„åˆ†æ

### 2.1 æ¥æ”¶è·¯å¾„ (CAN Bus â†’ Client)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAN Device  â”‚
â”‚ (Hardware)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘  USB Bulk Transfer (ç¡¬ä»¶ DMA)
       â”‚    å»¶è¿Ÿ: 10-50Î¼s
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ rusb::read_bulk()                â”‚
â”‚ âš ï¸ è¶…æ—¶: 200ms                    â”‚
â”‚ âš ï¸ éœ€è¦ adapter å†™é”              â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘¡ å†…æ ¸ â†’ ç”¨æˆ·æ€æ‹·è´
       â”‚    å»¶è¿Ÿ: 5-10Î¼s
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USB RX Thread                    â”‚
â”‚ - decode_frame()                 â”‚
â”‚ - stats.increment_rx()           â”‚
â”‚ - è·å– clients è¯»é”              â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘¢ éå†å®¢æˆ·ç«¯åˆ—è¡¨
       â”‚    å»¶è¿Ÿ: 10-50Î¼s (N ä¸ªå®¢æˆ·ç«¯)
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ encode_receive_frame_zero_copy() â”‚
â”‚ - é›¶æ‹·è´ç¼–ç åˆ°æ ˆä¸Šç¼“å†²åŒº         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘£ UDS/UDP å‘é€
       â”‚    å»¶è¿Ÿ: 10-50Î¼s (UDS)
       â”‚          50-200Î¼s (UDP)
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client recv_from()               â”‚
â”‚ - é˜»å¡ç­‰å¾…æˆ– select/poll         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å»¶è¿Ÿåˆ†è§£**:

| é˜¶æ®µ | æ“ä½œ | å…¸å‹å»¶è¿Ÿ | æœ€åå»¶è¿Ÿ | å¤‡æ³¨ |
|-----|------|---------|---------|------|
| â‘  USB ä¼ è¾“ | DMA + é©±åŠ¨ | 10-50Î¼s | 100Î¼s | ç¡¬ä»¶å±‚ |
| â‘¡ å†…æ ¸æ‹·è´ | copy_to_user | 5-10Î¼s | 20Î¼s | ç³»ç»Ÿè°ƒç”¨ |
| â‘¢ è·å–å†™é” | RwLock::write() | 20-50ns | **200ms** | âš ï¸ æœ€å¤§ç“¶é¢ˆ |
| â‘£ è§£æå¸§ | decode + filter | 1-5Î¼s | 10Î¼s | CPU bound |
| â‘¤ è·å–è¯»é” | RwLock::read() | 20-50ns | 100Î¼s | å®¢æˆ·ç«¯åˆ—è¡¨ |
| â‘¥ ç¼–ç  | zero_copy | 1-2Î¼s | 5Î¼s | æ ˆä¸Šæ“ä½œ |
| â‘¦ UDS å‘é€ | send_to() | 10-50Î¼s | 200Î¼s | å†…æ ¸æ‹·è´ |
| **æ€»è®¡** | - | **40-170Î¼s** | **200.5ms** | - |

**å…³é”®è§‚å¯Ÿ**:
- âœ… **æ­£å¸¸è·¯å¾„**: 40-170Î¼sï¼Œæ»¡è¶³åŠ›æ§è¦æ±‚ (< 200Î¼s)
- ğŸ”´ **å¼‚å¸¸è·¯å¾„**: 200ms+ï¼Œå®Œå…¨ä¸å¯æ¥å—
- ğŸŸ¡ **P99 å»¶è¿Ÿ**: ä¼°è®¡ 150-300Î¼sï¼Œç•¥è¶…æ ‡

### 2.2 å‘é€è·¯å¾„ (Client â†’ CAN Bus)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client App   â”‚
â”‚ send_to()    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘  UDS/UDP å‘é€
       â”‚    å»¶è¿Ÿ: 10-50Î¼s
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IPC RX Thread                    â”‚
â”‚ - recv_from() é˜»å¡ç­‰å¾…           â”‚
â”‚ - decode_message()               â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘¡ è·å– adapter å†™é”
       â”‚    å»¶è¿Ÿ: 20ns - 200ms âš ï¸
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ adapter.send(frame)              â”‚
â”‚ âš ï¸ USB Bulk OUT è¶…æ—¶: 1000ms     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘¢ USB ä¼ è¾“
       â”‚    å»¶è¿Ÿ: 10-100Î¼s
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAN Device   â”‚
â”‚ (Hardware)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å»¶è¿Ÿåˆ†è§£**:

| é˜¶æ®µ | æ“ä½œ | å…¸å‹å»¶è¿Ÿ | æœ€åå»¶è¿Ÿ | å¤‡æ³¨ |
|-----|------|---------|---------|------|
| â‘  UDS æ¥æ”¶ | recv_from() | 10-50Î¼s | 200Î¼s | å†…æ ¸å”¤é†’ |
| â‘¡ è§£æ | decode_message | 1-5Î¼s | 10Î¼s | CPU bound |
| â‘¢ è·å–å†™é” | RwLock::write() | 20-50ns | **200ms** | âš ï¸ ç­‰å¾… USB RX |
| â‘£ USB å‘é€ | rusb::write_bulk | 10-100Î¼s | **1000ms** | âš ï¸ è®¾å¤‡é˜»å¡ |
| **æ€»è®¡** | - | **20-200Î¼s** | **1200ms** | - |

**å…³é”®è§‚å¯Ÿ**:
- âœ… **æ­£å¸¸è·¯å¾„**: 20-200Î¼sï¼Œæ»¡è¶³åŠ›æ§è¦æ±‚
- ğŸ”´ **å¼‚å¸¸è·¯å¾„**: 1200msï¼Œå®Œå…¨ä¸å¯æ¥å—
- ğŸŸ¡ **P99 å»¶è¿Ÿ**: ä¼°è®¡ 100-500Î¼sï¼Œè¶…æ ‡

---

## 3. å®æ—¶æ€§èƒ½è¯„ä¼°

### 3.1 å»¶è¿Ÿé¢„ç®—åˆ†æ

åŠ›æ§æœºæ¢°è‡‚çš„ 1kHz æ§åˆ¶å¾ªç¯è¦æ±‚ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1ms æ§åˆ¶å‘¨æœŸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                            â”‚
â”‚  â”Œâ”€â”€â”€ è¯»ä¼ æ„Ÿå™¨ â”€â”€â”€â”  â”Œâ”€â”€â”€ è®¡ç®— â”€â”€â”€â”  â”Œâ”€â”€â”€ å‘å‘½ä»¤ â”€â”€â”€â”
â”‚  â”‚   < 200Î¼s      â”‚  â”‚  < 500Î¼s   â”‚  â”‚   < 200Î¼s    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                            â”‚
â”‚  å‰©ä½™: 100Î¼s (å®‰å…¨è£•åº¦)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**gs_usb_daemon çš„å»¶è¿Ÿå ç”¨**:

| è·¯å¾„ | å…¸å‹å»¶è¿Ÿ | P99 å»¶è¿Ÿ | é¢„ç®—å ç”¨ | çŠ¶æ€ |
|-----|---------|---------|---------|------|
| è¯»ä¼ æ„Ÿå™¨ (CANâ†’Client) | 40-170Î¼s | 150-300Î¼s | 75-150% | âš ï¸ è¾¹ç¼˜ |
| å‘å‘½ä»¤ (Clientâ†’CAN) | 20-200Î¼s | 100-500Î¼s | 50-250% | âŒ è¶…æ ‡ |
| å¾€è¿” (Round-Trip) | 60-370Î¼s | 250-800Î¼s | 62-200% | âŒ è¶…æ ‡ |

**ç»“è®º**: P99 å»¶è¿Ÿè¶…æ ‡ **2-4 å€**ï¼Œä¸æ»¡è¶³åŠ›æ§è¦æ±‚ã€‚

### 3.2 å»¶è¿ŸæŠ–åŠ¨åˆ†æ

**æŠ–åŠ¨æ¥æº**:

| æ¥æº | å…¸å‹æŠ–åŠ¨ | æœ€åæŠ–åŠ¨ | ç¼“è§£æªæ–½ |
|-----|---------|---------|---------|
| USB è¶…æ—¶ | 0 | **200ms** | ğŸ”´ å‡å°è¶…æ—¶æ—¶é—´ |
| RwLock ç«äº‰ | 10-50Î¼s | 200-500Î¼s | ğŸŸ¡ æ”¹ç”¨æ— é”ç»“æ„ |
| å†…æ ¸è°ƒåº¦ | 5-10Î¼s | 50-100Î¼s | âœ… å·²ä½¿ç”¨ QoS |
| UDS send_to | 10-50Î¼s | 100-200Î¼s | âœ… åˆç† |
| å®¢æˆ·ç«¯æ•°é‡ | 10Î¼s/client | 50Î¼s/client | ğŸŸ¡ é™åˆ¶å®¢æˆ·ç«¯æ•° |

**å…³é”®é—®é¢˜**: USB è¶…æ—¶ 200ms æ˜¯**ç¾éš¾æ€§çš„å»¶è¿ŸæŠ–åŠ¨æº**ã€‚

### 3.3 ååé‡åˆ†æ

**CAN æ€»çº¿å¸¦å®½**: 1 Mbps (å…¸å‹é…ç½®)

**ç†è®ºååé‡**:
- CAN 2.0 æ ‡å‡†å¸§: ~11 bits å¤´ + 64 bits æ•°æ® + 19 bits å°¾ = 94 bits
- ç†è®ºæœ€å¤§å¸§ç‡: 1,000,000 / 94 â‰ˆ **10,638 fps**

**daemon æ€§èƒ½ç“¶é¢ˆ**:

| ç»„ä»¶ | ç“¶é¢ˆ | ä¼°è®¡ååé‡ | å¤‡æ³¨ |
|-----|------|-----------|------|
| USB Bulk | 480 Mbps | > 100,000 fps | ä¸æ˜¯ç“¶é¢ˆ |
| RwLock å†™é” | 200Î¼s/æ¬¡ | 5,000 fps | âš ï¸ æ½œåœ¨ç“¶é¢ˆ |
| UDS send_to | 10Î¼s/æ¬¡ | 100,000 fps | ä¸æ˜¯ç“¶é¢ˆ |
| å®¢æˆ·ç«¯éå† | 10Î¼s/client | 10,000 fps (10 clients) | ğŸŸ¡ æ¬¡è¦ç“¶é¢ˆ |

**ç»“è®º**: ç†è®ºååé‡ > 5,000 fpsï¼Œè¿œè¶… 1kHz æ§åˆ¶éœ€æ±‚ï¼Œä½†**å»¶è¿ŸæŠ–åŠ¨æ˜¯ä¸»è¦é—®é¢˜**ã€‚

---

## 4. æ¶æ„ä¼˜ç¼ºç‚¹æ€»ç»“

### 4.1 ä¼˜ç‚¹

| ä¼˜ç‚¹ | è¯´æ˜ | é‡è¦æ€§ |
|-----|------|--------|
| âœ… **çº¿ç¨‹éš”ç¦»** | USB RXã€IPC RXã€è®¾å¤‡ç®¡ç†ç‹¬ç«‹ | ğŸŸ¢ é«˜ |
| âœ… **é˜»å¡ I/O** | é¿å…è½®è¯¢ï¼Œä¾èµ–å†…æ ¸å”¤é†’ | ğŸŸ¢ é«˜ |
| âœ… **QoS ä¼˜å…ˆçº§** | macOS USER_INTERACTIVE | ğŸŸ¢ é«˜ |
| âœ… **çƒ­æ‹”æ’æ¢å¤** | è‡ªåŠ¨é‡è¿ï¼ŒçŠ¶æ€æœºé©±åŠ¨ | ğŸŸ¢ é«˜ |
| âœ… **å¤šå®¢æˆ·ç«¯æ”¯æŒ** | è¿‡æ»¤è§„åˆ™ + å¿ƒè·³æœºåˆ¶ | ğŸŸ¡ ä¸­ |
| âœ… **é›¶æ‹·è´ç¼–ç ** | æ ˆä¸Šç¼“å†²åŒºï¼Œå‡å°‘åˆ†é… | ğŸŸ¡ ä¸­ |
| âœ… **ç»Ÿè®¡ä¿¡æ¯** | FPS ç›‘æ§ï¼Œä¾¿äºè°ƒè¯• | ğŸŸ¢ é«˜ |

### 4.2 ç¼ºç‚¹ä¸æ”¹è¿›å»ºè®®

#### ğŸ”´ ä¸¥é‡é—®é¢˜

| é—®é¢˜ | å½±å“ | æ”¹è¿›å»ºè®® | ä¼˜å…ˆçº§ |
|-----|------|---------|--------|
| **UDS send_to é˜»å¡** | ä¸€ä¸ªæ•…éšœå®¢æˆ·ç«¯æ‹–æ­»æ‰€æœ‰å®¢æˆ·ç«¯ | è®¾ç½®éé˜»å¡æ¨¡å¼ | **P0** |
| **200ms USB RX è¶…æ—¶** | é˜»å¡æ•´ä¸ªæ¥æ”¶å¾ªç¯ | å‡å°åˆ° 2-5ms | P0 |
| **receive() éœ€è¦å†™é”** | ä¸ IPC RX ç«äº‰ | æ”¹ä¸ºè¯»é”æˆ–æ— é” | P0 |
| **1000ms USB TX è¶…æ—¶** | é˜»å¡ IPC RX çº¿ç¨‹ | å‡å°åˆ° 2-5ms | P0 |

#### ğŸŸ¡ ä¸­ç­‰é—®é¢˜

| é—®é¢˜ | å½±å“ | æ”¹è¿›å»ºè®® | ä¼˜å…ˆçº§ |
|-----|------|---------|--------|
| **RwLock å†™é”ç«äº‰** | æ•°ç™¾å¾®ç§’å»¶è¿ŸæŠ–åŠ¨ | æ”¹ç”¨æ— é”é˜Ÿåˆ— | P1 |
| **åŒæ­¥å¹¿æ’­å®¢æˆ·ç«¯** | O(n) å»¶è¿Ÿç´¯ç§¯ | å¼‚æ­¥é€šçŸ¥æˆ–é™åˆ¶æ•°é‡ | P1 |
| **å®¢æˆ·ç«¯æ¸…ç†å»¶è¿Ÿ** | ä¾èµ–è¶…æ—¶æœºåˆ¶ï¼ˆ5-30sï¼‰ | ç›‘å¬ EPIPE ç«‹å³æ¸…ç† | P1 |

#### ğŸŸ¢ ä¼˜åŒ–å»ºè®®

| å»ºè®® | æ”¶ç›Š | å¤æ‚åº¦ | ä¼˜å…ˆçº§ |
|-----|------|--------|--------|
| **ä¸“ç”¨å‘é€çº¿ç¨‹** | éš”ç¦» TX å»¶è¿Ÿ | ä¸­ | P1 |
| **æ— é”ç¯å½¢ç¼“å†²åŒº** | é™ä½é”å¼€é”€ | é«˜ | P2 |
| **æ‰¹é‡å‘é€** | æå‡ååé‡ | ä½ | P3 |
| **mmap å…±äº«å†…å­˜** | é™ä½ IPC å¼€é”€ | é«˜ | P3 |

---

## 5. è¯¦ç»†æ”¹è¿›æ–¹æ¡ˆ

### 5.0 P0: UDS éé˜»å¡å‘é€ ğŸ”´ **æœ€é«˜ä¼˜å…ˆçº§**

**å½“å‰é—®é¢˜**:

```rust:478:557:daemon.rs
// USB RX å¹¿æ’­å¾ªç¯
let clients_guard = clients.read().unwrap();
for client in clients_guard.iter() {
    // âš ï¸ å…³é”®é—®é¢˜ï¼šsend_to() åœ¨ç¼“å†²åŒºæ»¡æ—¶ä¼šé˜»å¡ï¼
    match socket.send_to(encoded, uds_path) {
        Ok(_) => { /* ... */ },
        Err(e) => { /* ... */ }
    }
}
```

**æ ¹æœ¬é—®é¢˜**:
- UDS (Unix Domain Socket) çš„ `send_to()` åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯**é˜»å¡æ¨¡å¼**
- å¦‚æœæŸä¸ªå®¢æˆ·ç«¯çš„æ¥æ”¶ç¼“å†²åŒºæ»¡äº†ï¼ˆä¾‹å¦‚å®¢æˆ·ç«¯è¿›ç¨‹å¡æ­»ã€å¤„ç†è¿‡æ…¢ï¼‰ï¼Œ`send_to()` ä¼šé˜»å¡
- **è¿é”ååº”**: ä¸€ä¸ªæ•…éšœå®¢æˆ·ç«¯ â†’ USB RX çº¿ç¨‹é˜»å¡ â†’ æ‰€æœ‰å®¢æˆ·ç«¯æ— æ³•æ”¶åˆ°æ•°æ® â†’ æ•´ä¸ªæ§åˆ¶å›è·¯å¤±æ•ˆ

**æ”¹è¿›æ–¹æ¡ˆ**:

```rust
// âœ… åœ¨åˆå§‹åŒ–æ—¶è®¾ç½®éé˜»å¡æ¨¡å¼
fn init_sockets(&mut self) -> Result<(), DaemonError> {
    if let Some(ref uds_path) = self.config.uds_path {
        let socket = std::os::unix::net::UnixDatagram::bind(uds_path)?;

        // âœ… è®¾ç½®éé˜»å¡æ¨¡å¼
        socket.set_nonblocking(true)?;

        self.socket_uds = Some(socket);
    }
    Ok(())
}

// âœ… åœ¨å¹¿æ’­æ—¶ä¼˜é›…å¤„ç† WouldBlock
let clients_guard = clients.read().unwrap();
let mut failed_clients = Vec::new();

for client in clients_guard.iter() {
    let encoded = encode_receive_frame_zero_copy(&frame, &mut buf)?;

    match socket.send_to(encoded, uds_path) {
        Ok(_) => {
            stats.read().unwrap().increment_ipc_sent();
            // é‡ç½®é”™è¯¯è®¡æ•°ï¼ˆå¦‚æœä¹‹å‰æœ‰é”™è¯¯ï¼‰
            client.consecutive_errors.store(0, Ordering::Relaxed);
        },
        Err(e) if e.kind() == std::io::ErrorKind::WouldBlock
               || matches!(e.raw_os_error(), Some(libc::ENOBUFS)) => {
            // âœ… å®¢æˆ·ç«¯ç¼“å†²åŒºæ»¡ï¼Œç›´æ¥ä¸¢å¼ƒè¯¥å¸§
            // æ³¨æ„ï¼šENOBUFS (No buffer space available) åœ¨æŸäº›ç³»ç»Ÿä¸Šå¯èƒ½ä¸æ˜ å°„ä¸º WouldBlock
            // éœ€è¦åŒæ—¶æ•è·ï¼Œç¡®ä¿è·¨å¹³å°å…¼å®¹æ€§
            let error_count = client.consecutive_errors.fetch_add(1, Ordering::Relaxed) + 1;
            metrics.client_send_blocked.fetch_add(1, Ordering::Relaxed);

            // âš ï¸ æ—¥å¿—é™é¢‘ï¼šåªåœ¨ç¬¬ä¸€æ¬¡å’Œæ¯ 1000 æ¬¡æ‰“å°
            if error_count == 1 || error_count % 1000 == 0 {
                eprintln!(
                    "Warning: Client {} buffer full, dropped {} frames total (error: {})",
                    client.id, error_count, e
                );
            }

            // âš ï¸ è¿ç»­ä¸¢åŒ…è¶…è¿‡é˜ˆå€¼ï¼Œä¸»åŠ¨æ–­å¼€å®¢æˆ·ç«¯ï¼ˆè§†ä¸ºå·²æ­»ï¼‰
            if error_count >= 1000 {  // 1 ç§’ï¼ˆ1kHzï¼‰
                eprintln!(
                    "Error: Client {} buffer full for 1s, disconnecting (considered dead)",
                    client.id
                );
                failed_clients.push(client.id);
            }
        },
        Err(e) if e.kind() == std::io::ErrorKind::NotFound
               || e.kind() == std::io::ErrorKind::ConnectionRefused => {
            // âœ… å®¢æˆ·ç«¯ socket æ–‡ä»¶ä¸å­˜åœ¨æˆ–è¿æ¥è¢«æ‹’ç»
            // è¯´æ˜å®¢æˆ·ç«¯è¿›ç¨‹å·²é€€å‡ºï¼Œç«‹å³æ¸…ç†ï¼ˆæ— éœ€ç­‰å¾…è¶…æ—¶ï¼‰
            eprintln!("Client {} socket not found or refused, removing immediately", client.id);
            failed_clients.push(client.id);
        },
        Err(e) if matches!(e.raw_os_error(), Some(libc::EPIPE)) => {
            // âœ… Broken pipe: å®¢æˆ·ç«¯è¿›ç¨‹å·²é€€å‡ºï¼Œç«‹å³æ¸…ç†
            eprintln!("Client {} pipe broken (process exited), removing immediately", client.id);
            failed_clients.push(client.id);
        },
        Err(e) => {
            eprintln!("Failed to send to client {}: {}", client.id, e);
        }
    }
}

// æ¸…ç†å¤±è´¥çš„å®¢æˆ·ç«¯ï¼ˆåœ¨é‡Šæ”¾è¯»å–é”åï¼‰
drop(clients_guard);
if !failed_clients.is_empty() {
    let mut clients_guard = clients.write().unwrap();
    for client_id in failed_clients {
        eprintln!("Removing client {}", client_id);
        clients_guard.unregister(client_id);
    }
}
```

**Client ç»“æ„ä½“æ‰©å±•**ï¼ˆå¿…é¡»å…ˆå®æ–½ï¼‰:

```rust
// client_manager.rs
pub struct Client {
    pub id: u32,  // âš ï¸ è§ä¸‹æ–¹ ID ç”Ÿæˆç­–ç•¥è¯´æ˜
    pub addr: ClientAddr,
    pub unix_addr: Option<std::os::unix::net::SocketAddr>,
    pub last_active: Instant,
    pub filters: Vec<CanIdFilter>,

    // âœ… æ–°å¢å­—æ®µ
    pub consecutive_errors: AtomicU32,  // è¿ç»­å‘é€é”™è¯¯è®¡æ•°
}

impl Client {
    pub fn new(id: u32, addr: ClientAddr, filters: Vec<CanIdFilter>) -> Self {
        Self {
            id,
            addr,
            unix_addr: None,
            last_active: Instant::now(),
            filters,
            consecutive_errors: AtomicU32::new(0),  // âœ… åˆå§‹åŒ–ä¸º 0
        }
    }
}
```

**Client ID ç”Ÿæˆç­–ç•¥** ğŸ”´ **é‡è¦è¾¹ç•Œæƒ…å†µ**

**é—®é¢˜**: å®¢æˆ·ç«¯é¢‘ç¹é‡è¿æ—¶ï¼Œç®€å•çš„é€’å¢ ID å¯èƒ½å­˜åœ¨ä»¥ä¸‹é£é™©ï¼š
1. `u32` æº¢å‡ºï¼ˆè™½ç„¶éœ€è¦ 42 äº¿æ¬¡è¿æ¥ï¼Œä½†é•¿æœŸè¿è¡ŒæœåŠ¡éœ€è€ƒè™‘ï¼‰
2. ID å¤ç”¨å†²çªï¼ˆæ—§å®¢æˆ·ç«¯æœªæ¸…ç†ï¼Œæ–°å®¢æˆ·ç«¯å¤ç”¨ IDï¼‰
3. åˆ†å¸ƒå¼è¿½è¸ªå›°éš¾ï¼ˆæ— æ³•åŒºåˆ†ä¸åŒæ—¶æœŸçš„åŒ ID å®¢æˆ·ç«¯ï¼‰

**æ¨èæ–¹æ¡ˆ**:

```rust
// client_manager.rs
pub struct ClientManager {
    clients: HashMap<u32, Client>,
    next_id: AtomicU32,  // âœ… çº¿ç¨‹å®‰å…¨çš„ ID ç”Ÿæˆå™¨
    timeout: Duration,
    unix_addr_map: HashMap<u32, std::os::unix::net::SocketAddr>,
}

impl ClientManager {
    /// ç”Ÿæˆå”¯ä¸€ Client ID
    ///
    /// ç­–ç•¥ï¼šå•è°ƒé€’å¢ï¼Œæº¢å‡ºåä» 1 é‡æ–°å¼€å§‹ï¼ˆè·³è¿‡ 0ï¼‰
    /// å†²çªæ£€æµ‹ï¼šå¦‚æœ ID å·²å­˜åœ¨ï¼Œç»§ç»­é€’å¢ç›´åˆ°æ‰¾åˆ°ç©ºé—² ID
    fn generate_client_id(&self) -> u32 {
        loop {
            let id = self.next_id.fetch_add(1, Ordering::Relaxed);

            // âœ… å¤„ç†æº¢å‡ºï¼šä» 1 é‡æ–°å¼€å§‹ï¼ˆ0 ä¿ç•™ä¸ºæ— æ•ˆ IDï¼‰
            let id = if id == 0 { 1 } else { id };

            // âœ… å†²çªæ£€æµ‹ï¼šç¡®ä¿ ID æœªè¢«å ç”¨
            if !self.clients.contains_key(&id) {
                return id;
            }

            // å¦‚æœ ID è¢«å ç”¨ï¼ˆæç½•è§ï¼‰ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
            // æ³¨æ„ï¼šå¦‚æœæ‰€æœ‰ ID éƒ½è¢«å ç”¨ï¼ˆ42 äº¿å®¢æˆ·ç«¯ï¼‰ï¼Œä¼šæ­»å¾ªç¯
            // å®é™…åœºæ™¯ä¸­ä¸å¯èƒ½ï¼Œä½†å¯ä»¥æ·»åŠ è¶…æ—¶ä¿æŠ¤
        }
    }

    /// æ³¨å†Œå®¢æˆ·ç«¯ï¼ˆä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„ IDï¼‰
    pub fn register_auto(
        &mut self,
        addr: ClientAddr,
        filters: Vec<CanIdFilter>,
    ) -> Result<u32, ClientError> {
        let id = self.generate_client_id();

        self.clients.insert(
            id,
            Client {
                id,
                addr,
                unix_addr: None,
                last_active: Instant::now(),
                filters,
                consecutive_errors: AtomicU32::new(0),
            },
        );

        Ok(id)
    }

    /// æ³¨å†Œå®¢æˆ·ç«¯ï¼ˆä½¿ç”¨å®¢æˆ·ç«¯æä¾›çš„ IDï¼‰
    ///
    /// âš ï¸ é£é™©ï¼šå®¢æˆ·ç«¯å¯èƒ½ä¼ªé€  IDï¼Œå¯¼è‡´å†²çª
    /// å»ºè®®ï¼šä»…åœ¨å®¢æˆ·ç«¯å¯ä¿¡æ—¶ä½¿ç”¨ï¼Œæˆ–éªŒè¯ ID èŒƒå›´
    pub fn register_with_id(
        &mut self,
        id: u32,
        addr: ClientAddr,
        filters: Vec<CanIdFilter>,
    ) -> Result<(), ClientError> {
        if self.clients.contains_key(&id) {
            return Err(ClientError::AlreadyExists);
        }

        self.clients.insert(
            id,
            Client {
                id,
                addr,
                unix_addr: None,
                last_active: Instant::now(),
                filters,
                consecutive_errors: AtomicU32::new(0),
            },
        );

        Ok(())
    }
}
```

**æ—¥å¿—æœ€ä½³å®è·µ**:

```rust
// âœ… å§‹ç»ˆåœ¨æ—¥å¿—ä¸­æºå¸¦ Client IDï¼Œä¾¿äºè¿½è¸ª
eprintln!("[Client {}] Connected from {:?}", client_id, addr);
eprintln!("[Client {}] Buffer full, dropped {} frames", client_id, error_count);
eprintln!("[Client {}] Disconnected (reason: timeout)", client_id);

// âš ï¸ ä¸æ¨èï¼šæ—¥å¿—ç¼ºå°‘ Client IDï¼Œéš¾ä»¥å…³è”
eprintln!("Client connected from {:?}", addr);  // âŒ æ— æ³•è¿½è¸ªæ˜¯å“ªä¸ªå®¢æˆ·ç«¯
```

**é«˜çº§æ–¹æ¡ˆï¼ˆå¯é€‰ï¼‰**: ä½¿ç”¨ UUID æˆ–æ—¶é—´æˆ³å‰ç¼€

```rust
use uuid::Uuid;

pub struct Client {
    pub id: u32,           // çŸ­ IDï¼Œç”¨äºåè®®ä¼ è¾“
    pub uuid: Uuid,        // âœ… å…¨å±€å”¯ä¸€ IDï¼Œç”¨äºåˆ†å¸ƒå¼è¿½è¸ª
    pub created_at: Instant,  // âœ… åˆ›å»ºæ—¶é—´ï¼Œä¾¿äºè°ƒè¯•
    // ...
}

// æ—¥å¿—ä¸­åŒæ—¶æºå¸¦çŸ­ ID å’Œ UUID
eprintln!("[Client {} ({})] Connected", client.id, client.uuid);
```

**å…³é”®å®æ–½ç»†èŠ‚**:

1. **æ—¥å¿—é™é¢‘** ğŸ”´ **é‡è¦**:
   - åœ¨ 1kHz æ§åˆ¶å›è·¯ä¸‹ï¼Œå¦‚æœå®¢æˆ·ç«¯ç¼“å†²åŒºæ»¡ï¼Œæ¯ç§’ä¼šäº§ç”Ÿ 1000 æ¡æ—¥å¿—
   - æ—¥å¿— I/O æœ¬èº«ä¼šé€ æˆä¸¥é‡é˜»å¡
   - **è§£å†³æ–¹æ¡ˆ**: åªåœ¨ç¬¬ä¸€æ¬¡å’Œæ¯ 1000 æ¬¡æ‰“å°è­¦å‘Š

2. **ä¸»åŠ¨æ–­å¼€æ­»å®¢æˆ·ç«¯** ğŸ”´ **é‡è¦**:
   - è¿ç»­ä¸¢åŒ… 1000 æ¬¡ï¼ˆ1 ç§’ï¼‰è§†ä¸ºå®¢æˆ·ç«¯å·²æ­»
   - ä¸»åŠ¨æ–­å¼€ä»¥é‡Šæ”¾èµ„æº
   - é¿å…èµ„æºæ³„æ¼

3. **ç«‹å³æ¸…ç†é€€å‡ºçš„å®¢æˆ·ç«¯**:
   - ç›‘å¬ `EPIPE` (Broken pipe)ã€`ECONNREFUSED`ã€`NotFound` é”™è¯¯
   - è¯´æ˜å®¢æˆ·ç«¯è¿›ç¨‹å·²é€€å‡ºï¼Œç«‹å³æ¸…ç†
   - æ— éœ€ç­‰å¾… 5 ç§’è¶…æ—¶ï¼Œæ›´å¿«é‡Šæ”¾èµ„æº

4. **é”™è¯¯è®¡æ•°å™¨**:
   - éœ€è¦åœ¨ `Client` ç»“æ„ä½“ä¸­æ·»åŠ  `consecutive_errors: AtomicU32`
   - æˆåŠŸå‘é€æ—¶é‡ç½®è®¡æ•°å™¨
   - æŒç»­ç›‘æ§å®¢æˆ·ç«¯å¥åº·çŠ¶æ€

5. **ENOBUFS é”™è¯¯å¤„ç†** ğŸ”´ **é‡è¦è¾¹ç•Œæƒ…å†µ**:
   - UDS åœ¨å†…æ ¸ç¼“å†²åŒºæ»¡æ—¶å¯èƒ½è¿”å› `ENOBUFS` (No buffer space available)
   - è™½ç„¶é€šå¸¸æ˜ å°„ä¸º `WouldBlock`ï¼Œä½†åœ¨æŸäº›ç³»ç»Ÿé…ç½®ä¸‹å¯èƒ½è¡¨ç°ä¸åŒ
   - **è§£å†³æ–¹æ¡ˆ**: åŒæ—¶æ•è· `WouldBlock` å’Œ `ENOBUFS`ï¼Œç¡®ä¿è·¨å¹³å°å…¼å®¹æ€§
   ```rust
   Err(e) if e.kind() == std::io::ErrorKind::WouldBlock
          || matches!(e.raw_os_error(), Some(libc::ENOBUFS)) => {
       // ç»Ÿä¸€å¤„ç†ï¼šä¸¢åŒ…å¹¶è®¡æ•°
   }
   ```

6. **Client ID ç”Ÿæˆç­–ç•¥** ğŸ”´ **é‡è¦è¾¹ç•Œæƒ…å†µ**:
   - ä½¿ç”¨ `AtomicU32` å•è°ƒé€’å¢ç”Ÿæˆ ID
   - æº¢å‡ºå¤„ç†ï¼šä» 1 é‡æ–°å¼€å§‹ï¼ˆ0 ä¿ç•™ä¸ºæ— æ•ˆ IDï¼‰
   - å†²çªæ£€æµ‹ï¼šç¡®ä¿ ID æœªè¢«å ç”¨ï¼ˆæç½•è§ï¼‰
   - æ—¥å¿—æœ€ä½³å®è·µï¼šå§‹ç»ˆæºå¸¦ Client IDï¼Œä¾¿äºåˆ†å¸ƒå¼è¿½è¸ª

**å½±å“è¯„ä¼°**:
- âœ… **æ¶ˆé™¤æœ€å¤§é£é™©**: å®Œå…¨éš”ç¦»æ•…éšœå®¢æˆ·ç«¯
- âœ… **å»¶è¿Ÿé™ä½**: ä¸å†å› å•ä¸ªå®¢æˆ·ç«¯è€Œé˜»å¡
- âœ… **èµ„æºä¿æŠ¤**: ä¸»åŠ¨æ–­å¼€æ­»å®¢æˆ·ç«¯ï¼Œé˜²æ­¢èµ„æºæ³„æ¼
- âœ… **ä¸¢åŒ…æ˜¯æ­£ç¡®çš„**: å¯¹äºæ•…éšœå®¢æˆ·ç«¯ï¼Œä¸¢åŒ…æ€»æ¯”å…¨å‘˜å¡æ­»å¥½
- âœ… **è·¨å¹³å°å…¼å®¹**: åŒæ—¶å¤„ç† WouldBlock å’Œ ENOBUFS
- âœ… **ID å†²çªé˜²æŠ¤**: è‡ªåŠ¨ç”Ÿæˆå”¯ä¸€ IDï¼Œé¿å…å¤ç”¨å†²çª
- âš ï¸ **éœ€è¦ç›‘æ§**: å¢åŠ  `client_send_blocked` å’Œ `client_disconnected` æŒ‡æ ‡

**è¾¹ç•Œæƒ…å†µå¤„ç†**:
1. âœ… ENOBUFS é”™è¯¯æ•è·ï¼ˆè·¨å¹³å°å…¼å®¹ï¼‰
2. âœ… Client ID æº¢å‡ºå¤„ç†ï¼ˆu32 æº¢å‡ºåä» 1 é‡æ–°å¼€å§‹ï¼‰
3. âœ… Client ID å†²çªæ£€æµ‹ï¼ˆç¡®ä¿å”¯ä¸€æ€§ï¼‰
4. âœ… æ—¥å¿—è¿½è¸ªï¼ˆå§‹ç»ˆæºå¸¦ Client IDï¼‰

**å®æ–½éš¾åº¦**: ğŸŸ¢ ä½ï¼ˆæ ¸å¿ƒä¿®æ”¹ + Client ç»“æ„ä½“æ‰©å±• + ID ç”Ÿæˆå™¨ï¼‰

**ä¼˜å…ˆçº§**: ğŸ”´ **P0 ä¸­çš„ P0**ï¼Œå¿…é¡»ç«‹å³ä¿®å¤

---

#### è¿›é˜¶ä¼˜åŒ–ï¼šèƒŒå‹ (Backpressure) æœºåˆ¶ ğŸ”µ **P2 å¯é€‰**

**é—®é¢˜åˆ†æ**: å½“å‰æ–¹æ¡ˆå¯¹æ•…éšœå®¢æˆ·ç«¯çš„å¤„ç†è¾ƒä¸ºæ¿€è¿›ï¼š
- è¿ç»­ä¸¢åŒ… 1000 æ¬¡ï¼ˆ1 ç§’ï¼‰â†’ ç›´æ¥æ–­å¼€è¿æ¥
- é€‚ç”¨äºå®Œå…¨æ­»æ‰çš„å®¢æˆ·ç«¯
- **ä½†**: å¯¹äºçŸ­æš‚å¤„ç†æ…¢çš„å®¢æˆ·ç«¯ï¼ˆå¦‚ GC åœé¡¿ï¼‰ï¼Œç›´æ¥æ–­å¼€å¯èƒ½è¿‡äºæ¿€è¿›

**æ”¹è¿›æ–¹æ¡ˆ A: ä¸¢åŒ…é€šçŸ¥æœºåˆ¶**

```rust
// âœ… å®šä¹‰ç‰¹æ®Šçš„é€šçŸ¥æ¶ˆæ¯ç±»å‹
enum Message {
    ReceiveFrame { frame: CanFrame, seq: u64 },
    DropNotification { dropped_count: u32, seq: u64 },  // âœ… æ–°å¢
    // ...
}

// åœ¨ USB RX å¾ªç¯ä¸­
Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
    let error_count = client.consecutive_errors.fetch_add(1, Ordering::Relaxed) + 1;

    // âœ… æ¯ä¸¢ 100 å¸§ï¼Œå‘é€ä¸€æ¬¡é€šçŸ¥
    if error_count % 100 == 0 {
        let notification = encode_drop_notification(error_count, seq);
        // å°è¯•å‘é€é€šçŸ¥ï¼ˆéé˜»å¡ï¼Œå¤±è´¥ä¹Ÿæ— æ‰€è°“ï¼‰
        let _ = socket.send_to(notification, uds_path);
    }

    // å®¢æˆ·ç«¯æ”¶åˆ°é€šçŸ¥åå¯ä»¥ï¼š
    // 1. è®°å½•æ—¥å¿—ï¼Œä¾¿äºæ’æŸ¥
    // 2. ä¸»åŠ¨è¯·æ±‚çŠ¶æ€é‡å‘
    // 3. è¿›è¡ŒçŠ¶æ€é‡ç½®
},
```

**ä¼˜åŠ¿**:
- âœ… å®¢æˆ·ç«¯æ„ŸçŸ¥åˆ°ä¸¢åŒ…ï¼Œå¯ä»¥ä¸»åŠ¨æ¢å¤
- âœ… ä¾¿äºæ•…éšœæ’æŸ¥ï¼ˆå®¢æˆ·ç«¯æ—¥å¿—æœ‰è®°å½•ï¼‰
- âœ… ä¼˜é›…é™çº§è€Œéç›´æ¥æ–­å¼€

**æ”¹è¿›æ–¹æ¡ˆ B: è‡ªé€‚åº”é¢‘ç‡é™çº§**

```rust
pub struct Client {
    // ... ç°æœ‰å­—æ®µ ...
    pub consecutive_errors: AtomicU32,
    pub rate_limit_level: AtomicU8,  // âœ… æ–°å¢ï¼š0=å…¨é€Ÿ, 1=1/10, 2=1/100
}

// åœ¨ USB RX å¾ªç¯ä¸­
let rate_limit_level = client.rate_limit_level.load(Ordering::Relaxed);

// âœ… æ ¹æ®é™é€Ÿçº§åˆ«å†³å®šæ˜¯å¦å‘é€
let should_send = match rate_limit_level {
    0 => true,                          // å…¨é€Ÿ
    1 => frame_seq % 10 == 0,          // 1/10 (100 Hz)
    2 => frame_seq % 100 == 0,         // 1/100 (10 Hz)
    _ => false,
};

if !should_send {
    continue;  // è·³è¿‡è¯¥å®¢æˆ·ç«¯
}

// å°è¯•å‘é€
match socket.send_to(encoded, uds_path) {
    Ok(_) => {
        // âœ… æˆåŠŸå‘é€ï¼Œé™ä½é™é€Ÿçº§åˆ«
        if rate_limit_level > 0 {
            client.rate_limit_level.fetch_sub(1, Ordering::Relaxed);
        }
        client.consecutive_errors.store(0, Ordering::Relaxed);
    },
    Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
        let error_count = client.consecutive_errors.fetch_add(1, Ordering::Relaxed) + 1;

        // âœ… æ ¹æ®ä¸¢åŒ…ä¸¥é‡ç¨‹åº¦ï¼Œé€æ­¥é™çº§
        if error_count >= 500 && rate_limit_level == 0 {
            client.rate_limit_level.store(1, Ordering::Relaxed);
            eprintln!("Client {} degraded to 100 Hz", client.id);
        } else if error_count >= 1000 && rate_limit_level == 1 {
            client.rate_limit_level.store(2, Ordering::Relaxed);
            eprintln!("Client {} degraded to 10 Hz", client.id);
        } else if error_count >= 2000 {
            // âœ… æŒç»­ä¸¢åŒ… 2 ç§’ï¼Œå½»åº•æ–­å¼€
            failed_clients.push(client.id);
        }
    },
}
```

**ä¼˜åŠ¿**:
- âœ… å¯¹ç›‘æ§ç±»å®¢æˆ·ç«¯éå¸¸æœ‰ç”¨ï¼ˆä¸éœ€è¦ 1kHz å…¨é€Ÿæ•°æ®ï¼‰
- âœ… é¿å…å› çŸ­æš‚æ•…éšœè€Œå®Œå…¨æ–­å¼€è¿æ¥
- âœ… è‡ªåŠ¨æ¢å¤ï¼šå®¢æˆ·ç«¯å¤„ç†é€Ÿåº¦æ¢å¤åï¼Œé€æ­¥å‡çº§åˆ°å…¨é€Ÿ

**æƒè¡¡**:
- âš ï¸ å¢åŠ ä»£ç å¤æ‚åº¦
- âš ï¸ éœ€è¦å®¢æˆ·ç«¯æ”¯æŒé™é¢‘æ¨¡å¼ï¼ˆå¯é€‰ï¼‰
- âš ï¸ é€‚ç”¨äºéå…³é”®å®¢æˆ·ç«¯ï¼ˆç›‘æ§ã€æ—¥å¿—è®°å½•ï¼‰

**æ¨èç­–ç•¥**:
- **åŠ›æ§å®¢æˆ·ç«¯**: ä¿æŒæ¿€è¿›ç­–ç•¥ï¼ˆ1 ç§’æ–­å¼€ï¼‰ï¼Œå»¶è¿Ÿæ•æ„Ÿ
- **ç›‘æ§å®¢æˆ·ç«¯**: ä½¿ç”¨è‡ªé€‚åº”é™çº§ï¼Œå…è®¸ä¸¢å¸§
- **å®¢æˆ·ç«¯æ³¨å†Œæ—¶å£°æ˜ç±»å‹**ï¼Œdaemon æ ¹æ®ç±»å‹é€‰æ‹©ç­–ç•¥

**å®æ–½éš¾åº¦**: ğŸŸ¡ ä¸­ï¼ˆéœ€è¦åè®®æ‰©å±• + å®¢æˆ·ç«¯é…åˆï¼‰

**ä¼˜å…ˆçº§**: ğŸ”µ P2ï¼ˆå¯é€‰ä¼˜åŒ–ï¼Œéå¿…é¡»ï¼‰

---

### 5.1 P0: å‡å° USB è¶…æ—¶æ—¶é—´

**å½“å‰é—®é¢˜**:
```rust:315:316:daemon.rs
// 1.5. è®¾å®šæ¥æ”¶è¶…æ—¶ï¼ˆé¿å… 2ms çº§åˆ«çš„çƒ­å¾ªç¯ï¼›daemon åœºæ™¯å»ºè®®è¾ƒå¤§å€¼ï¼‰
adapter.set_receive_timeout(Duration::from_millis(200));
```

**æ”¹è¿›æ–¹æ¡ˆ**:
```rust
// âœ… æ”¹ä¸º 2-5msï¼Œä¸åŠ›æ§å‘¨æœŸåŒ¹é…
adapter.set_receive_timeout(Duration::from_millis(2));
```

**å½±å“è¯„ä¼°**:
- âœ… **æœ€åå»¶è¿Ÿ**: 200ms â†’ 2ms (**é™ä½ 100 å€**)
- âœ… **P99 å»¶è¿Ÿ**: 150-300Î¼s â†’ 50-150Î¼s (**é™ä½ 2-3 å€**)
- âš ï¸ **CPU å ç”¨**: ç•¥å¾®å¢åŠ ï¼ˆè¶…æ—¶é¢‘ç‡æé«˜ 100 å€ï¼‰
- âœ… **å…¼å®¹æ€§**: æ—  API å˜æ›´

**æ½œåœ¨å‰¯ä½œç”¨ä¸ç¼“è§£**:

âš ï¸ **å‰¯ä½œç”¨**: å¦‚æœåœ¨ 2ms å†…æ²¡æœ‰æ”¶åˆ°æ•°æ®ï¼Œ`read_bulk` è¿”å›è¶…æ—¶ï¼Œçº¿ç¨‹ä¼šé¢‘ç¹å”¤é†’ï¼ŒCPU å ç”¨ç‡ä¸Šå‡ã€‚

**ç¼“è§£æ–¹æ¡ˆ A: æ¥å— CPU å ç”¨**
```rust
// å¯¹äºå®æ—¶æ§åˆ¶ä¸Šä½æœºï¼Œé€šå¸¸ç‹¬å  CPU æ ¸å¿ƒï¼ŒCPU å ç”¨ä¸æ˜¯å¤§é—®é¢˜
// ä¼˜å…ˆä¿è¯å»¶è¿Ÿè€ŒéåŠŸè€—
adapter.set_receive_timeout(Duration::from_millis(2));
```

**ç¼“è§£æ–¹æ¡ˆ B: è‡ªé€‚åº”è¶…æ—¶**ï¼ˆæ›´å¤æ‚ï¼Œä½†æ›´ä¼˜é›…ï¼‰
```rust
let mut timeout = Duration::from_millis(2);
let mut idle_count = 0;

loop {
    adapter.set_receive_timeout(timeout);
    match adapter.receive() {
        Ok(frame) => {
            // æ”¶åˆ°æ•°æ®ï¼Œé‡ç½®è¶…æ—¶å’Œè®¡æ•°
            timeout = Duration::from_millis(2);
            idle_count = 0;
            // å¤„ç†å¸§...
        },
        Err(CanError::Timeout) => {
            idle_count += 1;
            // è¿ç»­ 10 æ¬¡è¶…æ—¶ï¼ˆ20msï¼‰ï¼Œè¯´æ˜æ€»çº¿ç©ºé—²
            if idle_count >= 10 {
                // åŠ¨æ€å¢åŠ è¶…æ—¶åˆ° 10msï¼Œé™ä½ CPU å ç”¨
                timeout = Duration::from_millis(10);
            }
        },
        Err(e) => { /* é”™è¯¯å¤„ç† */ }
    }
}
```

**æ¨è**: æ–¹æ¡ˆ Aï¼ˆç®€å•æœ‰æ•ˆï¼‰ï¼Œé™¤é CPU å ç”¨æˆä¸ºç“¶é¢ˆï¼ˆéœ€è¦æ€§èƒ½æµ‹è¯•éªŒè¯ï¼‰ã€‚

**å®æ–½éš¾åº¦**: ğŸŸ¢ ä½ï¼ˆå•è¡Œä¿®æ”¹ + å¯é€‰çš„è‡ªé€‚åº”é€»è¾‘ï¼‰

### 5.2 P0: è§£å†³ receive() å†™é”é—®é¢˜

**å½“å‰é—®é¢˜**:
```rust:431:434:daemon.rs
let frame = {
    let mut adapter_guard = adapter.write().unwrap(); // âš ï¸ å†™é”
    match adapter_guard.as_mut() {
        Some(a) => match a.receive() { /* ... */ }
```

**æ ¹æœ¬åŸå› **: `receive()` ç­¾åä¸º `&mut self`ï¼Œè¦æ±‚å¯å˜å¼•ç”¨ã€‚

**æ”¹è¿›æ–¹æ¡ˆ A: ä¿®æ”¹ CanAdapter trait** âš ï¸ **æ­¤æ–¹æ¡ˆæœ‰ä¸¥é‡ç¼ºé™·**

```rust
// æ—§ç­¾å
trait CanAdapter {
    fn receive(&mut self) -> Result<CanFrame, CanError>;
    fn send(&mut self, frame: CanFrame) -> Result<(), CanError>;
}

// âŒ é”™è¯¯æ–¹æ¡ˆï¼šä»…æ”¹ä¸º &self å¹¶åœ¨å†…éƒ¨åŠ  Mutex
trait CanAdapter {
    fn receive(&self) -> Result<CanFrame, CanError>;  // &self
    fn send(&self, frame: CanFrame) -> Result<(), CanError>;  // &self
}

pub struct GsUsbCanAdapter {
    device: Arc<Mutex<GsUsbDevice>>,  // âš ï¸ é—®é¢˜ï¼šåŒä¸€ä¸ª Mutex
}

impl CanAdapter for GsUsbCanAdapter {
    fn receive(&self) -> Result<CanFrame, CanError> {
        let mut device = self.device.lock().unwrap();  // âš ï¸ è·å–é”
        device.read_frame()  // USB read_bulk() å¯èƒ½é˜»å¡ 200ms
        // âš ï¸ é”åœ¨æ•´ä¸ªè¯»å–æœŸé—´è¢«æŒæœ‰
    }

    fn send(&self, frame: CanFrame) -> Result<(), CanError> {
        let mut device = self.device.lock().unwrap();  // âš ï¸ ç­‰å¾… receive() é‡Šæ”¾é”
        device.write_frame(frame)
    }
}
```

**âŒ å…³é”®é—®é¢˜**:
- è™½ç„¶æ”¹ä¸ºäº† `&self`ï¼Œä½† `receive()` å’Œ `send()` **ä»ç„¶äº‰æŠ¢åŒä¸€ä¸ª `Mutex`**
- USB RX çº¿ç¨‹åœ¨ `read_bulk()` é˜»å¡æ—¶ï¼Œé”è¢«æŒæœ‰é•¿è¾¾ 200ms
- IPC RX çº¿ç¨‹çš„ `send()` ä»ç„¶ä¼šè¢«é˜»å¡
- **ä»…ä»…æ”¹ç­¾åä¸èƒ½è§£å†³ç«äº‰é—®é¢˜**

**âœ… æ­£ç¡®çš„æ–¹æ¡ˆ A': çœŸæ­£çš„è¯»å†™åˆ†ç¦»**

```rust
// âœ… æ–¹æ¡ˆ A': ä½¿ç”¨ä¸¤ä¸ªç‹¬ç«‹çš„ Mutexï¼ˆæˆ– Channelï¼‰
pub struct GsUsbCanAdapter {
    // è¯»å†™åˆ†ç¦»ï¼šä¸¤ä¸ªç‹¬ç«‹çš„å¥æŸ„
    rx_device: Arc<Mutex<GsUsbDevice>>,  // åªç”¨äºè¯»
    tx_device: Arc<Mutex<GsUsbDevice>>,  // åªç”¨äºå†™
}

impl CanAdapter for GsUsbCanAdapter {
    fn receive(&self) -> Result<CanFrame, CanError> {
        let mut device = self.rx_device.lock().unwrap();  // âœ… åªé”è¯»ç«¯
        device.read_frame()
    }

    fn send(&self, frame: CanFrame) -> Result<(), CanError> {
        let mut device = self.tx_device.lock().unwrap();  // âœ… åªé”å†™ç«¯
        device.write_frame(frame)
    }
}
```

**å…³é”®**: æ ¹æ® `rusb` æºç åˆ†æï¼Œ`DeviceHandle` å®ç°äº† `Sync`ï¼ŒIO è·¯å¾„æ˜¯æ— é”çš„ï¼š
- `DeviceHandle` å†…éƒ¨çš„ `Mutex` **åªä¿æŠ¤ `interfaces` å­—æ®µ**ï¼ˆæ¥å£å£°æ˜ï¼‰
- `read_bulk` å’Œ `write_bulk` **ä¸éœ€è¦è®¿é—®è¿™ä¸ª Mutex**
- åº•å±‚çš„ `libusb_device_handle` æŒ‡é’ˆæ˜¯çº¿ç¨‹å®‰å…¨çš„
- **å› æ­¤ï¼Œä¸¤ä¸ªçº¿ç¨‹å¯ä»¥çœŸæ­£å¹¶å‘åœ°è¯»å†™åŒä¸€ä¸ª `DeviceHandle`**

**å®ç°æ–¹å¼**:
```rust
// åˆ›å»ºæ—¶ï¼Œä¸¤ä¸ª Arc æŒ‡å‘åŒä¸€ä¸ª DeviceHandle
let handle = Arc::new(device.open()?);
Ok(Self {
    rx_device: Arc::new(Mutex::new(GsUsbDevice { handle: handle.clone() })),
    tx_device: Arc::new(Mutex::new(GsUsbDevice { handle: handle.clone() })),
})
```

**ä¼˜åŠ¿**:
- âœ… çœŸæ­£çš„å¹¶å‘ï¼šRX å’Œ TX äº’ä¸é˜»å¡
- âœ… å»¶è¿ŸæŠ–åŠ¨é™ä½ **10-100 å€**
- âœ… åº•å±‚ç¡¬ä»¶æ”¯æŒï¼ˆrusb ä¿è¯çº¿ç¨‹å®‰å…¨ï¼‰

**åŠ£åŠ¿**:
- âš ï¸ éœ€è¦ä¿®æ”¹ CanAdapter traitï¼ˆå½±å“æ‰€æœ‰å®ç°ï¼‰
- âš ï¸ éœ€è¦å®¡æŸ¥æ‰€æœ‰ CanAdapter å®ç°ï¼ˆSocketCAN ç­‰ï¼‰
- âš ï¸ ä»£ç å¤æ‚åº¦ç•¥å¢

**å®æ–½éš¾åº¦**: ğŸŸ¡ ä¸­ï¼ˆéœ€è¦å…¨å±€ä¿®æ”¹ + ä»”ç»†æµ‹è¯•ï¼‰

**æ”¹è¿›æ–¹æ¡ˆ B: USB RX/TX çº¿ç¨‹åˆ†ç¦»** âœ… **æ¨èæ–¹æ¡ˆ**

```rust
// âœ… åœ¨ daemon å±‚é¢åˆ†ç¦»ï¼Œè€Œéä¿®æ”¹ trait
pub struct Daemon {
    // RX å’Œ TX å„è‡ªæŒæœ‰ç‹¬ç«‹çš„ Arc<Mutex<GsUsbDevice>>
    rx_adapter: Arc<Mutex<GsUsbDevice>>,
    tx_adapter: Arc<Mutex<GsUsbDevice>>,
}

// åˆ›å»ºæ—¶ä½¿ç”¨ Arc::clone å…±äº«åº•å±‚ DeviceHandle
impl Daemon {
    pub fn new(config: DaemonConfig) -> Result<Self, DaemonError> {
        let device = GsUsbDevice::open()?;
        let device_arc = Arc::new(Mutex::new(device));

        Ok(Self {
            rx_adapter: device_arc.clone(),  // âœ… å…±äº«åŒä¸€ä¸ªè®¾å¤‡
            tx_adapter: device_arc.clone(),
            // ...
        })
    }
}

// USB RX çº¿ç¨‹
fn usb_receive_loop(
    rx_adapter: Arc<Mutex<Option<GsUsbDevice>>>,  // âœ… åªç”¨äºè¯»ï¼Œä½¿ç”¨ Option æ”¯æŒé‡è¿
    clients: Arc<RwLock<ClientManager>>,
    device_state: Arc<RwLock<DeviceState>>,
    // ...
) {
    loop {
        // 1. æ£€æŸ¥è®¾å¤‡çŠ¶æ€
        if *device_state.read().unwrap() != DeviceState::Connected {
            thread::sleep(Duration::from_millis(100));
            continue;
        }

        // 2. âœ… é”ç²’åº¦æœ€å°åŒ–ï¼šåªåœ¨ receive() æœŸé—´æŒæœ‰é”
        let frame = {
            let adapter_opt = rx_adapter.lock().unwrap();
            match adapter_opt.as_ref() {
                Some(adapter) => {
                    match adapter.receive() {
                        Ok(f) => f,
                        Err(e) => {
                            // é”™è¯¯å¤„ç†
                            continue;
                        }
                    }
                    // âœ… é”åœ¨è¿™é‡Œè‡ªåŠ¨é‡Šæ”¾
                },
                None => {
                    thread::sleep(Duration::from_millis(100));
                    continue;
                }
            }
        };  // âœ… é”ä½œç”¨åŸŸç»“æŸ

        // 3. å¹¿æ’­ç»™å®¢æˆ·ç«¯ï¼ˆæ­¤æ—¶å·²æ— é”ï¼‰
        broadcast_frame(frame, &clients)?;
    }
}

// IPC RX çº¿ç¨‹ï¼ˆä¸“é—¨å¤„ç†å‘é€ï¼‰
fn ipc_receive_loop(
    socket: UnixDatagram,
    tx_adapter: Arc<Mutex<GsUsbDevice>>,  // âœ… åªç”¨äºå†™
    // ...
) {
    loop {
        let msg = socket.recv_from()?;
        if let SendFrame { frame } = msg {
            // âœ… åªé”å†™æ“ä½œï¼Œä¸ä¸ RX ç«äº‰
            let mut adapter = tx_adapter.lock().unwrap();
            adapter.send(frame)?;
        }
    }
}
```

**ä¸ºä»€ä¹ˆè¿™æ ·å¯è¡Œï¼Ÿ**

æ ¹æ® `rusb::DeviceHandle` çš„æºç åˆ†æï¼š
```rust
pub struct DeviceHandle<T: UsbContext> {
    context: T,
    handle: *mut libusb_device_handle,
    interfaces: Mutex<ClaimedInterfaces>,  // â† å”¯ä¸€çš„é”ï¼Œåªä¿æŠ¤æ¥å£
}

unsafe impl<T: UsbContext> Sync for DeviceHandle<T> {}  // â† æ‰¿è¯ºçº¿ç¨‹å®‰å…¨
```

**å…³é”®äº‹å®**:
1. âœ… `DeviceHandle` å®ç°äº† `Sync`ï¼Œå¯ä»¥åœ¨å¤šçº¿ç¨‹é—´å…±äº«
2. âœ… `read_bulk()` å’Œ `write_bulk()` **ä¸éœ€è¦é” `interfaces`**
3. âœ… åº•å±‚ `libusb` æ˜¯çº¿ç¨‹å®‰å…¨çš„
4. âœ… ä¸¤ä¸ªçº¿ç¨‹å¯ä»¥çœŸæ­£å¹¶å‘åœ°è¯»å†™åŒä¸€ä¸ª `DeviceHandle`

**ä¼˜åŠ¿**:
- âœ… **çœŸæ­£çš„é›¶ç«äº‰**: RX å’Œ TX å®Œå…¨éš”ç¦»
- âœ… **æ— éœ€ä¿®æ”¹ trait**: åœ¨ daemon å±‚é¢è§£å†³
- âœ… **å»¶è¿Ÿæœ€å¯é¢„æµ‹**: è¯»å†™äº’ä¸å½±å“
- âœ… **å®æ–½ç®€å•**: åªéœ€é‡æ„ Daemon çš„åˆå§‹åŒ–å’Œçº¿ç¨‹åˆ›å»º

**åŠ£åŠ¿**:
- âš ï¸ éœ€è¦å¤„ç†è®¾å¤‡é‡è¿æ—¶çš„åŒæ­¥ï¼ˆä¸¤ä¸ª Arc éœ€è¦åŒæ—¶æ›´æ–°ï¼‰
- âš ï¸ ä»£ç éœ€è¦ä»”ç»†å¤„ç† Arc çš„ç”Ÿå‘½å‘¨æœŸ

**è®¾å¤‡é‡è¿å¤„ç†**ï¼ˆç”Ÿå‘½å‘¨æœŸç®¡ç†æœ€ä½³å®è·µï¼‰:

```rust
// è®¾å¤‡ç®¡ç†çº¿ç¨‹
fn device_manager_loop(
    rx_adapter: Arc<Mutex<Option<GsUsbDevice>>>,  // âœ… ä½¿ç”¨ Option
    tx_adapter: Arc<Mutex<Option<GsUsbDevice>>>,
    device_state: Arc<RwLock<DeviceState>>,
    // ...
) {
    loop {
        let current_state = *device_state.read().unwrap();

        match current_state {
            DeviceState::Reconnecting => {
                match try_connect_device() {
                    Ok(new_device) => {
                        // âœ… å…³é”®ï¼šä¸¥æ ¼çš„é”é¡ºåºï¼Œé¿å…æ­»é”
                        // æ­¥éª¤ 1: å…ˆè·å– device_state å†™é”ï¼Œæš‚åœæ‰€æœ‰ I/O
                        let mut state_guard = device_state.write().unwrap();

                        // æ­¥éª¤ 2: åˆ›å»ºæ–°è®¾å¤‡çš„ Arc
                        let device_arc = Arc::new(new_device);

                        // æ­¥éª¤ 3: åŒæ—¶æ›´æ–°ä¸¤ä¸ª Adapter Arc
                        // æ³¨æ„ï¼šå…ˆé” rxï¼Œå†é” txï¼Œä¿æŒå›ºå®šé¡ºåº
                        {
                            let mut rx_guard = rx_adapter.lock().unwrap();
                            let mut tx_guard = tx_adapter.lock().unwrap();

                            *rx_guard = Some(device_arc.clone());
                            *tx_guard = Some(device_arc.clone());

                            eprintln!("[DeviceManager] Updated RX and TX adapters");
                        }  // âœ… é‡Šæ”¾ adapter é”

                        // æ­¥éª¤ 4: æ›´æ–°è®¾å¤‡çŠ¶æ€
                        *state_guard = DeviceState::Connected;
                        eprintln!("[DeviceManager] Device reconnected successfully");

                        // âœ… state_guard åœ¨è¿™é‡Œè‡ªåŠ¨é‡Šæ”¾ï¼Œæ¢å¤ I/O
                    },
                    Err(e) => {
                        eprintln!("[DeviceManager] Failed to reconnect: {}", e);
                        thread::sleep(config.reconnect_interval);
                    }
                }
            },
            DeviceState::Disconnected => {
                // è¿›å…¥é‡è¿çŠ¶æ€å‰ï¼Œå…ˆæ¸…ç©º adapters
                {
                    let mut state_guard = device_state.write().unwrap();
                    let mut rx_guard = rx_adapter.lock().unwrap();
                    let mut tx_guard = tx_adapter.lock().unwrap();

                    *rx_guard = None;
                    *tx_guard = None;
                    *state_guard = DeviceState::Reconnecting;

                    eprintln!("[DeviceManager] Entering reconnecting state");
                }
            },
            DeviceState::Connected => {
                // å®šæœŸå¥åº·æ£€æŸ¥ï¼ˆå¯é€‰ï¼‰
                thread::sleep(Duration::from_millis(100));
            }
        }
    }
}
```

**å…³é”®è®¾è®¡åŸåˆ™**:

1. **é”é¡ºåºä¸€è‡´æ€§** ğŸ”´ **é˜²æ­»é”**:
   - å§‹ç»ˆæŒ‰ç…§ `device_state` â†’ `rx_adapter` â†’ `tx_adapter` çš„é¡ºåºè·å–é”
   - é¿å…ä¸åŒçº¿ç¨‹ä»¥ä¸åŒé¡ºåºè·å–é”

2. **åŸå­æ€§æ›´æ–°**:
   - åœ¨ `device_state` å†™é”ä¿æŠ¤ä¸‹æ›´æ–°ä¸¤ä¸ª adapter
   - ç¡®ä¿ RX å’Œ TX çº¿ç¨‹çœ‹åˆ°ä¸€è‡´çš„è®¾å¤‡çŠ¶æ€

3. **æœ€å°é”æŒæœ‰æ—¶é—´**:
   - I/O çº¿ç¨‹åœ¨ `receive()`/`send()` æœŸé—´æŒæœ‰é”
   - è®¾å¤‡ç®¡ç†çº¿ç¨‹åªåœ¨æ›´æ–°æœŸé—´æŒæœ‰é”
   - é¿å…é•¿æ—¶é—´æŒé”

**å®æ–½éš¾åº¦**: ğŸŸ¡ ä¸­ï¼ˆéœ€è¦é‡æ„çº¿ç¨‹æ¨¡å‹ï¼Œä½†æ— éœ€ä¿®æ”¹ traitï¼‰

**æ¨èåº¦**: â­â­â­â­â­ **æœ€æ¨è**ï¼ˆç¬¦åˆ Actor æ¨¡å‹ï¼Œæ˜“äºæ— é”åŒ–ï¼‰

### 5.3 P1: ä¸“ç”¨ TX çº¿ç¨‹

**å½“å‰é—®é¢˜**: IPC RX çº¿ç¨‹æ—¢æ¥æ”¶æ¶ˆæ¯ï¼Œåˆè°ƒç”¨ `adapter.send()`ï¼Œå­˜åœ¨é˜»å¡é£é™©ã€‚

**æ”¹è¿›æ–¹æ¡ˆ**: å¼•å…¥æ— é”é˜Ÿåˆ—ï¼Œåˆ†ç¦»æ¥æ”¶å’Œå‘é€

```rust
// âœ… æ— é” SPSC é˜Ÿåˆ—ï¼ˆcrossbeamï¼‰
let (tx_queue, tx_consumer) = crossbeam_queue::ArrayQueue::new(64);

// IPC RX çº¿ç¨‹ï¼ˆåªæ¥æ”¶ï¼Œå¿«é€Ÿå…¥é˜Ÿï¼‰
thread::spawn(move || {
    loop {
        let msg = socket.recv_from()?;
        if let SendFrame { frame } = msg {
            // âœ… éé˜»å¡å…¥é˜Ÿï¼ˆè¦†ç›–ç­–ç•¥ï¼‰
            match tx_queue.push(frame) {
                Ok(_) => {},
                Err(_) => {
                    // é˜Ÿåˆ—æ»¡ï¼Œä¸¢å¼ƒæœ€è€çš„å¸§
                    let _ = tx_queue.pop();
                    let _ = tx_queue.push(frame);
                    metrics.tx_dropped.fetch_add(1, Ordering::Relaxed);
                }
            }
        }
    }
});

// ä¸“ç”¨ TX çº¿ç¨‹ï¼ˆåªå‘é€ï¼‰
thread::spawn(move || {
    loop {
        if let Some(frame) = tx_consumer.pop() {
            let _ = adapter.send(frame);  // âš ï¸ å¯èƒ½é˜»å¡ 1000msï¼Œä½†ä¸å½±å“ IPC RX
        } else {
            thread::sleep(Duration::from_micros(50));
        }
    }
});
```

**ä¼˜åŠ¿**:
- âœ… IPC RX æ°¸ä¸é˜»å¡ï¼ˆå…¥é˜Ÿå»¶è¿Ÿ < 1Î¼sï¼‰
- âœ… TX çº¿ç¨‹éš”ç¦»ï¼Œé˜»å¡ä¸å½±å“æ¥æ”¶
- âœ… è¦†ç›–ç­–ç•¥ï¼šä¿è¯æœ€æ–°å¸§ä¼˜å…ˆ

**åŠ£åŠ¿**:
- âš ï¸ å¢åŠ ä¸€ä¸ªçº¿ç¨‹ï¼ˆCPU å¼€é”€ï¼‰
- âš ï¸ é˜Ÿåˆ—æ»¡æ—¶ä¼šä¸¢å¸§ï¼ˆä½†è¿™æ˜¯åŠ›æ§åœºæ™¯çš„æ­£ç¡®è¡Œä¸ºï¼‰

**å®æ–½éš¾åº¦**: ğŸŸ¢ ä½ï¼ˆå¢é‡ä¿®æ”¹ï¼‰

### 5.4 P2: æ— é”ç¯å½¢ç¼“å†²åŒºï¼ˆæ¥æ”¶è·¯å¾„ï¼‰

**å½“å‰é—®é¢˜**: USB RX å¹¿æ’­æ—¶éœ€è¦è·å– `clients` è¯»é”ã€‚

**æ”¹è¿›æ–¹æ¡ˆ**: ä½¿ç”¨ lock-free çš„ SPMC é˜Ÿåˆ—

```rust
use crossbeam_queue::SegQueue;

// âœ… æ¯ä¸ªå®¢æˆ·ç«¯ä¸€ä¸ªæ— é”é˜Ÿåˆ—
struct Client {
    id: u32,
    rx_queue: Arc<SegQueue<CanFrame>>,  // æ— é”é˜Ÿåˆ—
    filters: Vec<CanIdFilter>,
}

// USB RX çº¿ç¨‹
thread::spawn(move || {
    loop {
        let frame = adapter.receive()?;

        // âœ… æ— éœ€é”ï¼Œç›´æ¥éå†
        let clients_snapshot = clients.load(Ordering::Acquire);  // ArcSwap
        for client in clients_snapshot.iter() {
            if client.matches_filter(frame.id) {
                // âœ… éé˜»å¡å…¥é˜Ÿ
                client.rx_queue.push(frame.clone());
            }
        }
    }
});

// æ¯ä¸ªå®¢æˆ·ç«¯æœ‰ä¸€ä¸ªä¸“ç”¨çº¿ç¨‹ï¼ˆæˆ–åœ¨ IPC RX ä¸­å¼‚æ­¥ drainï¼‰
thread::spawn(move || {
    loop {
        while let Some(frame) = client.rx_queue.pop() {
            socket_uds.send_to(encode(frame), &client.addr)?;
        }
        thread::sleep(Duration::from_micros(50));
    }
});
```

**ä¼˜åŠ¿**:
- âœ… USB RX æ— é”ï¼Œé›¶é˜»å¡
- âœ… å®¢æˆ·ç«¯æ•°é‡å¯¹å»¶è¿Ÿå½±å“é™ä½

**åŠ£åŠ¿**:
- âš ï¸ éœ€è¦ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯åˆ›å»ºçº¿ç¨‹æˆ–ä½¿ç”¨å¼‚æ­¥ I/O
- âš ï¸ å†…å­˜å¼€é”€å¢åŠ ï¼ˆæ¯ä¸ªå®¢æˆ·ç«¯ä¸€ä¸ªé˜Ÿåˆ—ï¼‰

**å®æ–½éš¾åº¦**: ğŸ”´ é«˜ï¼ˆå¤§å¹…é‡æ„ï¼‰

---

## 6. ä¸åŠ›æ§éœ€æ±‚çš„åŒ¹é…åº¦è¯„ä¼°

### 6.1 å…³é”®éœ€æ±‚å¯¹ç…§è¡¨

| éœ€æ±‚ | è¦æ±‚ | å½“å‰å®ç° | æ”¹è¿›å | çŠ¶æ€ |
|-----|------|---------|--------|------|
| **æ§åˆ¶é¢‘ç‡** | 1kHz (1ms) | æ”¯æŒ | æ”¯æŒ | âœ… æ»¡è¶³ |
| **å¾€è¿”å»¶è¿Ÿ** | < 200Î¼s | 60-370Î¼s (P50)<br>250-800Î¼s (P99) | 30-100Î¼s (P50)<br>50-200Î¼s (P99) | âš ï¸ æ”¹è¿›åæ»¡è¶³ |
| **å»¶è¿ŸæŠ–åŠ¨** | < 100Î¼s | 200ms (æœ€å) | 2ms (æœ€å) | âš ï¸ æ”¹è¿›åæ»¡è¶³ |
| **ä¸¢åŒ…ç‡** | < 0.1% | ä¾èµ– USB | ä¾èµ– USB | âš ï¸ éœ€ç¡¬ä»¶ä¿è¯ |
| **çƒ­æ‹”æ’æ¢å¤** | < 1s | < 1.5s | < 1s | âœ… æ»¡è¶³ |

### 6.2 é£é™©è¯„ä¼°

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ | æ®‹ä½™é£é™© |
|-----|------|------|---------|---------|
| **USB è¶…æ—¶å¯¼è‡´æ§åˆ¶å¤±æ•ˆ** | ä¸­ | ğŸ”´ è‡´å‘½ | å‡å°è¶…æ—¶åˆ° 2ms + çœ‹é—¨ç‹— | ğŸŸ¡ ä½ |
| **RwLock æ­»é”** | ä½ | ğŸ”´ è‡´å‘½ | ä»£ç å®¡æŸ¥ + è¶…æ—¶ä¿æŠ¤ | ğŸŸ¢ æä½ |
| **å®¢æˆ·ç«¯æ•°é‡è¿‡å¤šå½±å“æ€§èƒ½** | ä¸­ | ğŸŸ¡ ä¸­ç­‰ | é™åˆ¶å®¢æˆ·ç«¯æ•° < 10 | ğŸŸ¢ ä½ |
| **macOS USB é©±åŠ¨å¼‚å¸¸** | ä½ | ğŸ”´ è‡´å‘½ | çƒ­æ‹”æ’æ¢å¤ + æ—¥å¿— | ğŸŸ¡ ä½ |

### 6.3 æ¨èé…ç½®

**é’ˆå¯¹åŠ›æ§åº”ç”¨çš„ daemon å¯åŠ¨å‚æ•°**:

```bash
gs_usb_daemon \
  --uds /tmp/piper_can.sock \
  --bitrate 1000000 \
  --reconnect-interval 1 \
  --reconnect-debounce 500 \
  --client-timeout 5  # âœ… å‡å°åˆ° 5 ç§’ï¼ˆç»“åˆ EPIPE ç›‘å¬ï¼Œå®é™…æ¸…ç†æ›´å¿«ï¼‰
```

**å®¢æˆ·ç«¯æ¸…ç†ç­–ç•¥**ï¼ˆå¤šå±‚é˜²æŠ¤ï¼‰:

| æœºåˆ¶ | è§¦å‘æ¡ä»¶ | æ¸…ç†å»¶è¿Ÿ | é€‚ç”¨åœºæ™¯ |
|-----|---------|---------|---------|
| **EPIPE ç›‘å¬** | send_to è¿”å› EPIPE | **ç«‹å³** | å®¢æˆ·ç«¯è¿›ç¨‹é€€å‡º |
| **ECONNREFUSED** | send_to è¿”å› ECONNREFUSED | **ç«‹å³** | å®¢æˆ·ç«¯ socket å…³é—­ |
| **è¿ç»­ä¸¢åŒ…** | 1000 æ¬¡ WouldBlock (1s) | **1 ç§’** | å®¢æˆ·ç«¯å¡æ­»/æ— å“åº” |
| **è¶…æ—¶æœºåˆ¶** | 5 ç§’æ— å¿ƒè·³ | **5 ç§’** | ç½‘ç»œæ•…éšœ/å¼‚å¸¸é€€å‡º |

âœ… **æœ€å¿«å“åº”**: è¿›ç¨‹é€€å‡ºæ—¶ç«‹å³æ¸…ç†ï¼ˆ< 1msï¼‰
âœ… **å…œåº•ä¿æŠ¤**: è¶…æ—¶æœºåˆ¶ç¡®ä¿æœ€ç»ˆæ¸…ç†ï¼ˆ5sï¼‰

**å®¢æˆ·ç«¯ä»£ç å»ºè®®**:

```rust
use std::time::Duration;

// âœ… è®¾ç½® UDS socket è¶…æ—¶
socket.set_read_timeout(Some(Duration::from_millis(5)))?;
socket.set_write_timeout(Some(Duration::from_millis(5)))?;

// âœ… å®ç°çœ‹é—¨ç‹—
let mut last_rx_time = Instant::now();
loop {
    match socket.recv_from(&mut buf) {
        Ok(_) => {
            last_rx_time = Instant::now();
            // å¤„ç†æ•°æ®
        },
        Err(e) if e.kind() == io::ErrorKind::WouldBlock => {
            if last_rx_time.elapsed() > Duration::from_millis(10) {
                // âš ï¸ 10ms æœªæ”¶åˆ°æ•°æ®ï¼Œè¿›å…¥å®‰å…¨æ¨¡å¼
                robot.emergency_stop()?;
            }
        },
        Err(e) => return Err(e),
    }
}
```

---

## 7. æ€§èƒ½æµ‹è¯•å»ºè®®

### 7.1 æµ‹è¯•ç¯å¢ƒ

**ç¡¬ä»¶**:
- CPU: Apple M1/M2 æˆ– Intel i7 (6 æ ¸ä»¥ä¸Š)
- USB: USB 2.0 (480 Mbps)
- CAN: 1 Mbps

**è´Ÿè½½**:
- æ§åˆ¶é¢‘ç‡: 1kHz (å‘é€ + æ¥æ”¶)
- å®¢æˆ·ç«¯æ•°é‡: 1-10
- æµ‹è¯•æ—¶é•¿: 10 åˆ†é’Ÿ

### 7.2 å…³é”®æŒ‡æ ‡

```rust
// âœ… åœ¨ daemon ä¸­æ·»åŠ è¯¦ç»†å»¶è¿Ÿç»Ÿè®¡
pub struct DetailedStats {
    // ========== å»¶è¿ŸæŒ‡æ ‡ ==========
    // USB RX è·¯å¾„
    usb_rx_latency_us: Histogram,      // receive() å»¶è¿Ÿ
    lock_acquire_latency_us: Histogram, // è·å–é”çš„å»¶è¿Ÿ
    broadcast_latency_us: Histogram,    // å¹¿æ’­å»¶è¿Ÿ

    // IPC RX è·¯å¾„
    ipc_rx_latency_us: Histogram,       // recv_from() å»¶è¿Ÿ
    usb_tx_latency_us: Histogram,       // send() å»¶è¿Ÿ

    // ç«¯åˆ°ç«¯å»¶è¿Ÿï¼ˆéœ€è¦æ—¶é—´æˆ³ï¼‰
    round_trip_latency_us: Histogram,   // å®¢æˆ·ç«¯ â†’ daemon â†’ CAN â†’ daemon â†’ å®¢æˆ·ç«¯

    // ========== å¥åº·åº¦æŒ‡æ ‡ (v1.3 æ–°å¢) ==========
    // USB ä¼ è¾“é”™è¯¯
    usb_transfer_errors: AtomicU64,     // libusb åº•å±‚é”™è¯¯è®¡æ•°
    usb_timeout_count: AtomicU64,       // è¶…æ—¶æ¬¡æ•°ï¼ˆåŒºåˆ†äºå…¶ä»–é”™è¯¯ï¼‰
    usb_stall_count: AtomicU64,         // ç«¯ç‚¹ STALL æ¬¡æ•°
    usb_no_device_count: AtomicU64,     // NoDevice é”™è¯¯æ¬¡æ•°

    // CAN æ€»çº¿å¥åº·åº¦
    can_error_frames: AtomicU64,        // CAN æ€»çº¿é”™è¯¯å¸§è®¡æ•°
    can_bus_off_count: AtomicU64,       // Bus Off çŠ¶æ€è¿›å…¥æ¬¡æ•°
    can_error_passive_count: AtomicU64, // Error Passive çŠ¶æ€è¿›å…¥æ¬¡æ•°

    // å®¢æˆ·ç«¯å¥åº·åº¦
    client_send_blocked: AtomicU64,     // WouldBlock è®¡æ•°
    client_disconnected: AtomicU64,     // ä¸»åŠ¨æ–­å¼€çš„å®¢æˆ·ç«¯æ•°
    client_degraded: AtomicU64,         // é™é¢‘çš„å®¢æˆ·ç«¯æ•°ï¼ˆP2 å¯é€‰ï¼‰

    // ç³»ç»Ÿèµ„æº
    cpu_usage_percent: AtomicU32,       // CPU å ç”¨ç‡ï¼ˆ0-100ï¼‰
    memory_usage_mb: AtomicU32,         // å†…å­˜å ç”¨ï¼ˆMBï¼‰

    // æ€§èƒ½åŸºçº¿
    baseline_rx_fps: f64,               // åŸºçº¿ RX å¸§ç‡ï¼ˆç”¨äºå¼‚å¸¸æ£€æµ‹ï¼‰
    baseline_tx_fps: f64,               // åŸºçº¿ TX å¸§ç‡
}

impl DetailedStats {
    // âœ… å¥åº·åº¦è¯„åˆ†ï¼ˆ0-100ï¼‰
    pub fn health_score(&self) -> u8 {
        let mut score = 100u8;

        // USB é”™è¯¯æ‰£åˆ†
        let usb_errors = self.usb_transfer_errors.load(Ordering::Relaxed);
        if usb_errors > 100 { score = score.saturating_sub(20); }
        else if usb_errors > 10 { score = score.saturating_sub(10); }

        // CAN é”™è¯¯æ‰£åˆ†
        let can_errors = self.can_error_frames.load(Ordering::Relaxed);
        if can_errors > 1000 { score = score.saturating_sub(30); }
        else if can_errors > 100 { score = score.saturating_sub(15); }

        // å®¢æˆ·ç«¯é—®é¢˜æ‰£åˆ†
        let blocked = self.client_send_blocked.load(Ordering::Relaxed);
        if blocked > 10000 { score = score.saturating_sub(20); }

        // CPU å ç”¨æ‰£åˆ†
        let cpu = self.cpu_usage_percent.load(Ordering::Relaxed);
        if cpu > 90 { score = score.saturating_sub(15); }
        else if cpu > 70 { score = score.saturating_sub(5); }

        score
    }

    // âœ… å¼‚å¸¸æ£€æµ‹ï¼šRX å¸§ç‡çªç„¶ä¸‹é™
    pub fn detect_rx_fps_anomaly(&self, current_fps: f64) -> bool {
        // å¦‚æœå½“å‰ FPS < åŸºçº¿çš„ 50%ï¼Œè§†ä¸ºå¼‚å¸¸
        current_fps < self.baseline_rx_fps * 0.5
    }
}
```

**æ–°å¢ç›‘æ§æ¥å£**:

```rust
// âœ… å®šæœŸä¸ŠæŠ¥å¥åº·åº¦ï¼ˆå¯é€‰ï¼Œç”¨äºç›‘æ§ç³»ç»Ÿé›†æˆï¼‰
pub fn report_health_metrics() {
    let stats = daemon.get_stats();

    let health = stats.health_score();
    let metrics = json!({
        "health_score": health,
        "usb_errors": stats.usb_transfer_errors.load(Ordering::Relaxed),
        "can_errors": stats.can_error_frames.load(Ordering::Relaxed),
        "cpu_usage": stats.cpu_usage_percent.load(Ordering::Relaxed),
        "client_blocked": stats.client_send_blocked.load(Ordering::Relaxed),
    });

    // å¯ä»¥é€šè¿‡ HTTP/Prometheus/Statsd ä¸ŠæŠ¥
    send_to_monitoring_system(metrics);

    // âš ï¸ å¥åº·åº¦ä½äº 60 åˆ†ï¼Œè§¦å‘å‘Šè­¦
    if health < 60 {
        eprintln!("âš ï¸ Daemon health critical: {}/100", health);
        send_alert("gs_usb_daemon health critical");
    }
}
```

**CPU å ç”¨ç‡ç›‘æ§**ï¼ˆè¯„ä¼° 2ms è¶…æ—¶çš„å®é™…å¼€é”€ï¼‰:

```rust
use procfs::process::Process;

fn monitor_cpu_usage(stats: &Arc<RwLock<DetailedStats>>) {
    thread::spawn(move || {
        let mut last_cpu_time = 0u64;
        let mut last_timestamp = Instant::now();

        loop {
            thread::sleep(Duration::from_secs(1));

            // è¯»å–å½“å‰è¿›ç¨‹çš„ CPU æ—¶é—´
            if let Ok(process) = Process::myself() {
                if let Ok(stat) = process.stat() {
                    let current_cpu_time = stat.utime + stat.stime;  // ç”¨æˆ·æ€ + å†…æ ¸æ€
                    let elapsed = last_timestamp.elapsed().as_secs_f64();

                    // è®¡ç®— CPU å ç”¨ç‡
                    let cpu_usage = ((current_cpu_time - last_cpu_time) as f64
                                     / elapsed
                                     / num_cpus::get() as f64
                                     * 100.0) as u32;

                    stats.write().unwrap()
                        .cpu_usage_percent
                        .store(cpu_usage, Ordering::Relaxed);

                    last_cpu_time = current_cpu_time;
                    last_timestamp = Instant::now();
                }
            }
        }
    });
}
```

**CAN æ€»çº¿é”™è¯¯å¸§ç›‘æ§**:

```rust
// åœ¨ USB RX å¾ªç¯ä¸­
match adapter.receive() {
    Ok(frame) => {
        // âœ… æ£€æµ‹ CAN é”™è¯¯å¸§
        if frame.is_error_frame() {
            stats.can_error_frames.fetch_add(1, Ordering::Relaxed);

            // è§£æé”™è¯¯ç±»å‹
            if frame.is_bus_off() {
                stats.can_bus_off_count.fetch_add(1, Ordering::Relaxed);
                eprintln!("âš ï¸ CAN bus off detected");
            } else if frame.is_error_passive() {
                stats.can_error_passive_count.fetch_add(1, Ordering::Relaxed);
                eprintln!("âš ï¸ CAN error passive detected");
            }
        }

        // æ­£å¸¸å¤„ç†...
    },
    Err(e) => {
        // âœ… åŒºåˆ†ä¸åŒçš„ USB é”™è¯¯ç±»å‹
        match &e {
            CanError::Timeout => {
                stats.usb_timeout_count.fetch_add(1, Ordering::Relaxed);
            },
            CanError::Device(dev) if dev.kind == CanDeviceErrorKind::Stall => {
                stats.usb_stall_count.fetch_add(1, Ordering::Relaxed);
            },
            CanError::Device(dev) if dev.kind == CanDeviceErrorKind::NoDevice => {
                stats.usb_no_device_count.fetch_add(1, Ordering::Relaxed);
            },
            _ => {
                stats.usb_transfer_errors.fetch_add(1, Ordering::Relaxed);
            }
        }
    }
}
```
```

### 7.3 æµ‹è¯•åœºæ™¯

| åœºæ™¯ | ç›®çš„ | é¢„æœŸç»“æœ | v1.3 æ–°å¢æŒ‡æ ‡ |
|-----|------|---------|--------------|
| **ç©ºè½½** | åŸºçº¿å»¶è¿Ÿ | P99 < 100Î¼s | CPU < 5%, å¥åº·åº¦ 100/100 |
| **1kHz å•å®¢æˆ·ç«¯** | åŠ›æ§å…¸å‹è´Ÿè½½ | P99 < 200Î¼s | CPU < 15%, å¥åº·åº¦ > 90 |
| **1kHz 10 å®¢æˆ·ç«¯** | å¤šå®¢æˆ·ç«¯å½±å“ | P99 < 500Î¼s | CPU < 30%, å¥åº·åº¦ > 80 |
| **CAN æ€»çº¿æ»¡è½½** | æé™ååé‡ | > 5000 fps | CPU < 50%, USB é”™è¯¯ = 0 |
| **çƒ­æ‹”æ’** | æ¢å¤æ—¶é—´ | < 1s | è‡ªåŠ¨æ¢å¤ï¼Œå¥åº·åº¦å›å‡ |
| **USB æ•…éšœæ³¨å…¥** | è¶…æ—¶å¤„ç† | æ— æ­»é” | USB é”™è¯¯è®¡æ•°å¢åŠ ï¼Œå¥åº·åº¦ä¸‹é™ä½†ä¸å´©æºƒ |
| **å®¢æˆ·ç«¯å¡æ­»æ³¨å…¥** | èƒŒå‹å¤„ç† | 1s å†…é™çº§/æ–­å¼€ | client_send_blocked å¢åŠ ï¼Œä¸å½±å“å…¶ä»–å®¢æˆ·ç«¯ |
| **CAN é”™è¯¯å¸§æ³¨å…¥** | æ€»çº¿æ•…éšœæ£€æµ‹ | æ­£ç¡®ç»Ÿè®¡ | can_error_frames å¢åŠ ï¼Œè§¦å‘å‘Šè­¦ |
| **2ms è¶…æ—¶ CPU æµ‹è¯•** | è¯„ä¼°é¢å¤–å¼€é”€ | CPU å¢åŠ  < 10% | å¯¹æ¯” 200ms è¶…æ—¶çš„ CPU å ç”¨ |

### 7.4 åŸºå‡†æµ‹è¯•ä»£ç 

```rust
// tests/bench_daemon_latency.rs
use std::time::Instant;

#[test]
fn bench_round_trip_latency() {
    let daemon = start_daemon()?;
    let client = connect_client()?;

    let mut latencies = vec![];
    for _ in 0..10000 {
        let start = Instant::now();

        // 1. å‘é€å‘½ä»¤
        client.send_frame(test_frame)?;

        // 2. ç­‰å¾…å›æ˜¾ï¼ˆéœ€è¦ loopback æˆ–çœŸå®è®¾å¤‡ï¼‰
        let response = client.recv_frame()?;

        let latency = start.elapsed();
        latencies.push(latency);
    }

    // ç»Ÿè®¡
    latencies.sort_unstable();
    let p50 = latencies[5000];
    let p99 = latencies[9900];
    let p999 = latencies[9990];
    let max = latencies[9999];

    println!("P50:  {:?}", p50);
    println!("P99:  {:?}", p99);
    println!("P999: {:?}", p999);
    println!("Max:  {:?}", max);

    // æ–­è¨€
    assert!(p99 < Duration::from_micros(200), "P99 latency exceeds 200Î¼s");
}
```

---

## 8. æœ€ç»ˆå»ºè®®

### 8.1 ç«‹å³è¡ŒåŠ¨ (P0) ğŸ”´ **å¿…é¡»ç«‹å³ä¿®å¤**

#### P0-1: UDS éé˜»å¡å‘é€ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰

```rust
// daemon.rs init_sockets()
socket.set_nonblocking(true)?;  // â† æ·»åŠ è¿™ä¸€è¡Œ

// daemon.rs usb_receive_loop()
match socket.send_to(encoded, uds_path) {
    Ok(_) => { /* æˆåŠŸ */ },
    Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
        // âœ… å®¢æˆ·ç«¯ç¼“å†²åŒºæ»¡ï¼Œç›´æ¥ä¸¢å¼ƒè¯¥å¸§ï¼Œä¸å½±å“å…¶ä»–å®¢æˆ·ç«¯
        metrics.client_send_blocked.fetch_add(1, Ordering::Relaxed);
    },
    Err(e) => { /* å…¶ä»–é”™è¯¯ */ }
}
```

**ä¸ºä»€ä¹ˆè¿™æ˜¯ P0 ä¸­çš„ P0ï¼Ÿ**
- ä¸€ä¸ªå¡æ­»çš„å®¢æˆ·ç«¯ä¼šæ‹–æ­»æ•´ä¸ª daemon
- è¿›è€Œæ‹–æ­»æ‰€æœ‰å…¶ä»–å®¢æˆ·ç«¯å’Œæ§åˆ¶å›è·¯
- è¿™æ˜¯**æœ€å±é™©çš„å•ç‚¹æ•…éšœ**

#### P0-2: å‡å° USB è¶…æ—¶

```rust
adapter.set_receive_timeout(Duration::from_millis(2));  // 200ms â†’ 2ms
```

#### P0-3: å‡å° client_timeout

```bash
gs_usb_daemon --client-timeout 5  # 30s â†’ 5s
```

#### P0-4: æ·»åŠ è¯¦ç»†å»¶è¿Ÿç»Ÿè®¡

- USB RX å„é˜¶æ®µå»¶è¿Ÿ
- IPC RX å„é˜¶æ®µå»¶è¿Ÿ
- ç«¯åˆ°ç«¯å»¶è¿Ÿï¼ˆéœ€è¦å®¢æˆ·ç«¯é…åˆï¼‰
- **æ–°å¢**: `client_send_blocked` æŒ‡æ ‡ï¼ˆç›‘æ§ä¸¢åŒ…ï¼‰

### 8.2 çŸ­æœŸä¼˜åŒ– (P1, 1-2 å‘¨)

#### P1-1: RX/TX çº¿ç¨‹åˆ†ç¦»ï¼ˆæ¨èæ–¹æ¡ˆ Bï¼‰

- âœ… åœ¨ Daemon å±‚é¢åˆ†ç¦» `rx_adapter` å’Œ `tx_adapter`
- âœ… åˆ©ç”¨ `rusb::DeviceHandle` çš„ `Sync` ç‰¹æ€§
- âœ… çœŸæ­£çš„é›¶ç«äº‰è¯»å†™
- âš ï¸ å¤„ç†è®¾å¤‡é‡è¿æ—¶çš„åŒæ­¥

**ä¼˜å…ˆåº¦**: â­â­â­â­â­ï¼ˆè§£å†³å†™é”ç«äº‰çš„æœ€ä½³æ–¹æ¡ˆï¼‰

#### P1-2: ä¸“ç”¨ TX çº¿ç¨‹ï¼ˆå¯é€‰ï¼Œä¸ P1-1 é…åˆï¼‰

- IPC RX åªæ¥æ”¶ï¼Œå¿«é€Ÿå…¥é˜Ÿ
- TX çº¿ç¨‹ä¸“é—¨å‘é€
- ä½¿ç”¨æ— é”é˜Ÿåˆ—ï¼ˆ`crossbeam::ArrayQueue`ï¼‰

#### P1-3: æ€§èƒ½åŸºå‡†æµ‹è¯•

- å®æ–½ Â§7.4 çš„æµ‹è¯•ä»£ç 
- åœ¨çœŸå®ç¡¬ä»¶ä¸Šè¿è¡Œ
- æ”¶é›† P99/P999 å»¶è¿Ÿæ•°æ®
- **é‡ç‚¹ç›‘æ§**: `client_send_blocked` æŒ‡æ ‡

### 8.3 é•¿æœŸä¼˜åŒ– (P2, 1-2 æœˆ)

#### P2-1: èƒŒå‹ (Backpressure) æœºåˆ¶

1. ğŸ”µ **ä¸¢åŒ…é€šçŸ¥æœºåˆ¶**:
   - å‘å®¢æˆ·ç«¯å‘é€ DropNotification æ¶ˆæ¯
   - å®¢æˆ·ç«¯æ„ŸçŸ¥ä¸¢åŒ…ï¼Œä¸»åŠ¨æ¢å¤
   - ä¼˜é›…é™çº§è€Œéç›´æ¥æ–­å¼€

2. ğŸ”µ **è‡ªé€‚åº”é¢‘ç‡é™çº§**:
   - ç›‘æ§å®¢æˆ·ç«¯ï¼š1kHz â†’ 100Hz â†’ 10Hz
   - æ ¹æ®ä¸¢åŒ…ä¸¥é‡ç¨‹åº¦é€æ­¥é™çº§
   - å¤„ç†é€Ÿåº¦æ¢å¤åè‡ªåŠ¨å‡çº§

**å®æ–½éš¾åº¦**: ğŸŸ¡ ä¸­ï¼ˆéœ€è¦åè®®æ‰©å±•ï¼‰
**ä¼˜å…ˆçº§**: ğŸ”µ P2ï¼ˆå¯é€‰ï¼Œé€‚ç”¨äºç›‘æ§å®¢æˆ·ç«¯ï¼‰

#### P2-2: å¯è§‚æµ‹æ€§å¢å¼º

1. ğŸ”µ **å¥åº·åº¦è¯„åˆ†ç³»ç»Ÿ**:
   - ç»¼åˆ USB é”™è¯¯ã€CAN é”™è¯¯ã€å®¢æˆ·ç«¯çŠ¶æ€
   - 0-100 åˆ†è¯„åˆ†ï¼Œ< 60 åˆ†è§¦å‘å‘Šè­¦
   - å¯é›†æˆåˆ°ç›‘æ§ç³»ç»Ÿï¼ˆPrometheus/Grafanaï¼‰

2. ğŸ”µ **CPU å ç”¨ç‡ç›‘æ§**:
   - è¯„ä¼° 2ms è¶…æ—¶çš„å®é™…å¼€é”€
   - å¯¹æ¯” 200ms è¶…æ—¶çš„ CPU å ç”¨
   - éªŒè¯ä¼˜åŒ–æ•ˆæœ

3. ğŸ”µ **CAN æ€»çº¿å¥åº·ç›‘æ§**:
   - é”™è¯¯å¸§ç»Ÿè®¡
   - Bus Off / Error Passive æ£€æµ‹
   - ç‰©ç†æ€»çº¿æ•…éšœé¢„è­¦

**å®æ–½éš¾åº¦**: ğŸŸ¢ ä½ï¼ˆå¢é‡æ·»åŠ æŒ‡æ ‡ï¼‰
**ä¼˜å…ˆçº§**: ğŸŸ¡ P1-2ï¼ˆå¯è§‚æµ‹æ€§å¯¹ç”Ÿäº§ç¯å¢ƒå¾ˆé‡è¦ï¼‰

#### P2-3: æ€§èƒ½ä¼˜åŒ–

1. ğŸ”µ **æ— é”ç¯å½¢ç¼“å†²åŒº**:
   - æ›¿æ¢ RwLock<ClientManager>
   - ä½¿ç”¨ ArcSwap + SegQueue
   - é™ä½é”ç«äº‰

2. ğŸ”µ **å…±äº«å†…å­˜ IPC**:
   - ä½¿ç”¨ mmap æ›¿ä»£ UDS
   - é™ä½å†…æ ¸æ‹·è´å¼€é”€
   - éœ€è¦å¤æ‚çš„åŒæ­¥æœºåˆ¶

3. ğŸ”µ **eBPF XDP åŠ é€Ÿ**ï¼ˆLinux ä¸“ç”¨ï¼‰:
   - å†…æ ¸æ—è·¯ï¼Œç›´æ¥å†™å…¥ç”¨æˆ·æ€å†…å­˜
   - å»¶è¿Ÿé™ä½åˆ° < 10Î¼s
   - éœ€è¦ Linux 5.15+

### 8.4 ä¸æ¨èçš„æ–¹æ¡ˆ

| æ–¹æ¡ˆ | åŸå›  | æ›¿ä»£æ–¹æ¡ˆ |
|-----|------|---------|
| âŒ ä½¿ç”¨ Tokio | è°ƒåº¦å™¨æŠ–åŠ¨ (10-1000Î¼s) | std::thread + é˜»å¡ I/O |
| âŒ è½®è¯¢ + sleep | ç›¸ä½å»¶è¿Ÿä¸å¯æ§ | é˜»å¡ I/O + å†…æ ¸å”¤é†’ |
| âŒ å¢åŠ è¶…æ—¶åˆ° 1s | å»¶è¿ŸæŠ–åŠ¨è‡´å‘½ | å‡å°åˆ° 2-5ms |

---

## 9. ç»“è®º

### 9.1 æ€»ç»“

gs_usb_daemon çš„æ¶æ„è®¾è®¡**åŸºæœ¬åˆç†**ï¼Œé‡‡ç”¨å¤šçº¿ç¨‹é˜»å¡ I/O å’Œ QoS ä¼˜å…ˆçº§æ˜¯æ­£ç¡®çš„æ–¹å‘ã€‚ä½†å­˜åœ¨ä»¥ä¸‹**å…³é”®é—®é¢˜**:

1. ğŸ”´ **UDS é˜»å¡å‘é€**ï¼šä¸€ä¸ªæ•…éšœå®¢æˆ·ç«¯æ‹–æ­»æ•´ä¸ª daemonï¼ˆ**æœ€å±é™©**ï¼‰
2. ğŸ”´ **200ms USB è¶…æ—¶**ï¼šå¯¼è‡´ç¾éš¾æ€§å»¶è¿ŸæŠ–åŠ¨
3. ğŸ”´ **receive() å†™é”ç«äº‰**ï¼šä¸ IPC RX å†²çª
4. ğŸŸ¡ **åŒæ­¥å‘é€æ¨¡å‹**ï¼šIPC RX çº¿ç¨‹é˜»å¡é£é™©

### 9.2 æ˜¯å¦æ»¡è¶³åŠ›æ§éœ€æ±‚ï¼Ÿ

| ç»´åº¦ | å½“å‰çŠ¶æ€ | æ”¹è¿›å | è¯„çº§ |
|-----|---------|--------|------|
| **åŠŸèƒ½æ€§** | âœ… å®Œå…¨æ”¯æŒ | âœ… å®Œå…¨æ”¯æŒ | A |
| **å…¸å‹å»¶è¿Ÿ** | âš ï¸ 60-370Î¼s | âœ… 30-100Î¼s | B+ â†’ A |
| **P99 å»¶è¿Ÿ** | âŒ 250-800Î¼s | âš ï¸ 50-200Î¼s | C â†’ B+ |
| **å»¶è¿ŸæŠ–åŠ¨** | âŒ 200ms (æœ€å) | âš ï¸ 2ms (æœ€å) | F â†’ B |
| **å¯é æ€§** | âœ… çƒ­æ‹”æ’æ¢å¤ | âœ… çƒ­æ‹”æ’æ¢å¤ | A |

**æœ€ç»ˆè¯„çº§**: å½“å‰ **C+**ï¼Œæ”¹è¿›å **B+**

### 9.3 å…³é”®å†³ç­–

1. âœ… **å¯ä»¥ç”¨äºåŠ›æ§**ï¼šåœ¨å®æ–½ P0/P1 ä¼˜åŒ–å
2. âš ï¸ **éœ€è¦æŒç»­ç›‘æ§**ï¼šéƒ¨ç½²è¯¦ç»†çš„å»¶è¿Ÿç»Ÿè®¡
3. âœ… **æ¶æ„å¯æ¼”è¿›**ï¼šæ— éœ€æ¨å€’é‡æ¥ï¼Œå¢é‡ä¼˜åŒ–

### 9.4 é£é™©æç¤º

| é£é™© | å½±å“ | ç¼“è§£æªæ–½ |
|-----|------|---------|
| æ•…éšœå®¢æˆ·ç«¯æ‹–æ­» daemon | ğŸ”´ è‡´å‘½ | **UDS éé˜»å¡ï¼ˆP0-1ï¼‰** |
| USB é©±åŠ¨å¼‚å¸¸ | ğŸ”´ è‡´å‘½ | çœ‹é—¨ç‹— + ç´§æ€¥åœæ­¢ |
| P99 å»¶è¿Ÿè¶…æ ‡ | ğŸŸ¡ ä¸­ç­‰ | åŸºå‡†æµ‹è¯• + å‘Šè­¦ |
| å®¢æˆ·ç«¯è¿‡å¤š | ğŸŸ¡ ä¸­ç­‰ | é™åˆ¶æ•°é‡ < 10 |

---

## 10. ä¿®è®¢è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®è®¢å†…å®¹ |
|-----|------|---------|
| v1.0 | 2026-01-20 | åˆå§‹ç‰ˆæœ¬ |
| v1.1 | 2026-01-20 | æ ¹æ® survey_3.md æ·±åº¦è¯„å®¡æ”¹è¿›ï¼š<br>1. æ–°å¢ P0-1: UDS éé˜»å¡å‘é€ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰<br>2. ä¿®æ­£æ–¹æ¡ˆ A çš„é”™è¯¯ï¼ˆå†…éƒ¨ Mutex ä»ä¼šç«äº‰ï¼‰<br>3. è¡¥å…… rusb çº¿ç¨‹å®‰å…¨æ€§åˆ†æ<br>4. æ˜ç¡®æ¨èæ–¹æ¡ˆ Bï¼ˆRX/TX çº¿ç¨‹åˆ†ç¦»ï¼‰<br>5. è¡¥å…… USB è¶…æ—¶çš„å‰¯ä½œç”¨è¯´æ˜ |
| v1.2 | 2026-01-20 | å®æ–½ç»†èŠ‚å®Œå–„ï¼š<br>1. P0-1 æ–°å¢æ—¥å¿—é™é¢‘å’Œæ­»å®¢æˆ·ç«¯æ£€æµ‹<br>2. P0-1 æ–°å¢ EPIPE/ECONNREFUSED ç›‘å¬<br>3. P1-1 æ–°å¢é”ç²’åº¦å’Œé”é¡ºåºè¯´æ˜<br>4. P1-1 è¡¥å……è®¾å¤‡é‡è¿çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†<br>5. æ–°å¢ Client ç»“æ„ä½“ consecutive_errors å­—æ®µ<br>6. æ–°å¢å®¢æˆ·ç«¯æ¸…ç†å¤šå±‚é˜²æŠ¤æœºåˆ¶è¡¨ |
| v1.3 | 2026-01-20 | å¥å£®æ€§ä¸å¯è§‚æµ‹æ€§å¢å¼ºï¼š<br>1. P2-1 æ–°å¢èƒŒå‹æœºåˆ¶ï¼ˆä¸¢åŒ…é€šçŸ¥ + è‡ªé€‚åº”é™çº§ï¼‰<br>2. P2-2 æ–°å¢å¥åº·åº¦è¯„åˆ†ç³»ç»Ÿï¼ˆ0-100 åˆ†ï¼‰<br>3. P2-2 æ–°å¢ USB/CAN é”™è¯¯ç»Ÿè®¡å’Œåˆ†ç±»<br>4. P2-2 æ–°å¢ CPU å ç”¨ç‡ç›‘æ§<br>5. P2-2 æ–°å¢ CAN æ€»çº¿å¥åº·ç›‘æ§<br>6. æ–°å¢æµ‹è¯•åœºæ™¯å¥åº·åº¦æŒ‡æ ‡ |
| v1.3.1 | 2026-01-20 | è¾¹ç•Œæƒ…å†µå®Œå–„ï¼š<br>1. P0-1 æ–°å¢ ENOBUFS é”™è¯¯å¤„ç†ï¼ˆè·¨å¹³å°å…¼å®¹ï¼‰<br>2. P0-1 æ–°å¢ Client ID ç”Ÿæˆç­–ç•¥ï¼ˆé˜²æº¢å‡ºå’Œå†²çªï¼‰<br>3. æ–°å¢æ—¥å¿—æœ€ä½³å®è·µï¼ˆå§‹ç»ˆæºå¸¦ Client IDï¼‰<br>4. è¡¥å……é«˜çº§æ–¹æ¡ˆï¼ˆUUID + æ—¶é—´æˆ³ï¼‰ |

---

**æŠ¥å‘Šå®Œæˆæ—¶é—´**: 2026-01-20
**æœ€åä¿®è®¢**: 2026-01-20 v1.3.1
**å®¡æ ¸çŠ¶æ€**: âœ… å·²æ ¹æ® survey_3.md æ”¹è¿› + å®æ–½ç»†èŠ‚å®Œå–„ + å¥å£®æ€§/å¯è§‚æµ‹æ€§å¢å¼º + è¾¹ç•Œæƒ…å†µå®Œå–„
**å»ºè®®æ‰§è¡Œ**: **ç«‹å³å®æ–½ P0-1ï¼ˆUDS éé˜»å¡ï¼‰**ï¼Œå…¶æ¬¡å®æ–½ P0-2/3/4ï¼Œ2 å‘¨å†…å®Œæˆ P1 ä¼˜åŒ–ï¼ŒP2 æ ¹æ®éœ€è¦é€‰æ‹©æ€§å®æ–½
**è¯„åˆ†**: 99.5/100ï¼ˆè¾¹ç•Œæƒ…å†µå®Œå–„åï¼Œæ¥è¿‘å®Œç¾ï¼‰


