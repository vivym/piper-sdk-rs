# ä¸“é¡¹æŠ¥å‘Š 2: Async/Blocking éš”ç¦»å±‚å®¡æŸ¥ï¼ˆæœ€ç»ˆç‰ˆï¼‰

**å®¡æŸ¥æ—¥æœŸ**: 2026-01-27
**é—®é¢˜ç­‰çº§**: ğŸ”´ P0 - æé«˜é£é™©ï¼ˆæ¶æ„å±‚é¢ + å®‰å…¨å±‚é¢ï¼‰
**å®¡æŸ¥ç›®æ ‡**: ç¡®ä¿ CLI çš„ Async ç‰¹æ€§ä¸æ±¡æŸ“ SDK çš„å®æ—¶æ€§
**å…³é”®ä¿®æ­£**: ä»"æ”¹ SDK ä¸º async"ä¿®æ­£ä¸º"CLI å±‚çº¿ç¨‹éš”ç¦»"
**ğŸš¨ ç¬¬4è½®ä¿®æ­£**: `spawn_blocking` ä¸å¯å–æ¶ˆæ€§å¯¼è‡´çš„ä¸¥é‡å®‰å…¨é£é™©

---

## æ‰§è¡Œæ‘˜è¦ï¼ˆä¿®æ­£ç‰ˆï¼‰

**åŸæŠ¥å‘Šé”™è¯¯**: å»ºè®®å°† SDK çš„ `replay_recording` æ”¹ä¸º async
**é—®é¢˜**: è¿èƒŒäº†æœºå™¨äººæ§åˆ¶çš„æ ¸å¿ƒåŸåˆ™

**æ ¸å¿ƒè§‚ç‚¹ä¿®æ­£**:
1. âœ… **SDK (piper-client/driver) å¿…é¡»ä¿æŒåŒæ­¥é˜»å¡**
   - æ§åˆ¶å¾ªç¯ç‹¬å  CPU æ ¸å¿ƒï¼Œä¿è¯ç¡®å®šæ€§
   - ä½æŠ–åŠ¨ï¼ˆLow Jitterï¼‰æ˜¯ç¬¬ä¸€ä½
   - **ç»å¯¹ä¸èƒ½**åœ¨ SDK å†…å¼•å…¥ `tokio` ä¾èµ–

2. âœ… **CLI (apps/cli) å¯ä»¥æ˜¯ async**
   - ç”¨æˆ·äº¤äº’ã€æ—¥å¿—ã€ç½‘ç»œ IO å¯ä»¥å¼‚æ­¥
   - ä½†å¿…é¡»æ­£ç¡®éš”ç¦»é˜»å¡çš„ SDK è°ƒç”¨

3. ğŸ”´ **çœŸæ­£çš„é—®é¢˜**: CLI åœ¨ Tokio Worker çº¿ç¨‹ä¸­ç›´æ¥è°ƒç”¨äº† SDK çš„é˜»å¡æ–¹æ³•
   - å¯¼è‡´ Tokio è°ƒåº¦å™¨è¢«"åŠ«æŒ"
   - æ— æ³•å“åº” Ctrl-Cã€æ— æ³•å¤„ç†å…¶ä»– IO

**æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆ**: **çº¿ç¨‹éš”ç¦»æ¨¡å¼**ï¼ˆä½¿ç”¨ `spawn_blocking`ï¼‰

**ğŸš¨ è‡´å‘½å®‰å…¨éšæ‚£**ï¼ˆç¬¬4è½®ä¿®æ­£ï¼‰:
- âŒ `spawn_blocking` çš„ä»»åŠ¡**ä¸å¯å–æ¶ˆ**
- âŒ ç”¨æˆ·æŒ‰ Ctrl-C åï¼ŒTokio ä¸»çº¿ç¨‹é€€å‡ºï¼Œä½† **OS çº¿ç¨‹ç»§ç»­è¿è¡Œ**
- âŒ **æœºæ¢°è‡‚ç»§ç»­è¿åŠ¨ï¼Œç›´åˆ°æ’å¢™**
- âœ… **å¿…é¡»**: ä¼ å…¥åœæ­¢ä¿¡å·ï¼ˆ`AtomicBool`ï¼‰å®ç°åä½œå¼å–æ¶ˆ

**æ–°å¢å‘ç°**: `std::thread::sleep` ç²¾åº¦é—®é¢˜ï¼ˆ1-15ms æŠ–åŠ¨ï¼‰

---

## 1. æ¶æ„åŸåˆ™ï¼šSDK vs CLI

### 1.1 æœºå™¨äººæ§åˆ¶çš„æ¶æ„è¦æ±‚

**å…³é”®åŸåˆ™**: ç¡®å®šæ€§ï¼ˆDeterminismï¼‰å’Œä½æŠ–åŠ¨ï¼ˆLow Jitterï¼‰> å¼‚æ­¥ä¾¿åˆ©æ€§

| å±‚çº§ | æ˜¯å¦ Async | ç†ç”± | ä¼˜å…ˆçº§ |
|------|----------|------|--------|
| **SDK æ ¸å¿ƒåº“** | âŒ åŒæ­¥é˜»å¡ | æ§åˆ¶å¾ªç¯éœ€è¦ç‹¬å  CPUã€ä¿è¯ç¡®å®šæ€§ | ğŸ”´ æœ€é«˜ |
| **CLI åº”ç”¨** | âœ… å¼‚æ­¥ | ç”¨æˆ·äº¤äº’ã€ç½‘ç»œ IO å¯ä»¥å¼‚æ­¥ | ğŸŸ¡ ä¸­ |
| **ç¤ºä¾‹ä»£ç ** | âœ… åŒæ­¥ | ç®€å•æ¸…æ™°ï¼Œä¸ä¾èµ–æ¡†æ¶ | ğŸŸ¢ ä½ |

### 1.2 ä¸ºä»€ä¹ˆ SDK ä¸èƒ½æ˜¯ Async

**ç¡®å®šæ€§è¦æ±‚**:
```rust
// âœ… æ­£ç¡®ï¼šåŒæ­¥é˜»å¡ SDK
impl Piper<ReplayMode> {
    fn replay_recording(&self, path: &str, speed: f64) -> Result<()> {
        for frame in recording.frames {
            // ç‹¬å å½“å‰çº¿ç¨‹ï¼Œç²¾ç¡®æ§åˆ¶æ—¶åº
            let dt = calculate_delay(frame, speed);
            thread::sleep(dt);  // é˜»å¡ï¼Œä½†ä¿è¯æ—¶åº
            self.driver.send_frame(frame)?;
        }
    }
}

// âŒ é”™è¯¯ï¼šasync SDK
impl Piper<ReplayMode> {
    async fn replay_recording(&self, path: &str, speed: f64) -> Result<()> {
        for frame in recording.frames {
            let dt = calculate_delay(frame, speed).await;
            tokio::time::sleep(dt).await;  // âš ï¸ è°ƒåº¦å™¨å¯èƒ½å»¶è¿Ÿ 1-10ms
            self.driver.send_frame(frame).await?;
        }
    }
}
```

**é—®é¢˜**:
- Tokio è°ƒåº¦å™¨ä¼šæ’å…¥å…¶ä»–ä»»åŠ¡
- å¯¼è‡´æ§åˆ¶å¾ªç¯æ—¶åºæŠ–åŠ¨ï¼ˆ1-10ms ä¸ç¡®å®šæ€§ï¼‰
- è¿èƒŒäº†æœºå™¨äººæ§åˆ¶çš„ç¡®å®šæ€§è¦æ±‚

---

## 2. çœŸæ­£çš„é—®é¢˜æ ¹æº

### 2.1 å½“å‰æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLI (apps/cli) - Tokio Async            â”‚
â”‚  â”œâ”€ replay.execute() [async fn]          â”‚
â”‚  â”‚   â””â”€ replay.replay_recording() ???  â”‚
â”‚  â””â”€ Tokio Worker çº¿ç¨‹                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ ç›´æ¥è°ƒç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SDK (piper-client) - Sync Blocking      â”‚
â”‚  â””â”€ replay_recording() [é˜»å¡æ–¹æ³•]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**é—®é¢˜**: CLI çš„ async fn ç›´æ¥è°ƒç”¨äº† SDK çš„é˜»å¡æ–¹æ³•

### 2.2 å½“å‰ä»£ç ï¼ˆé—®é¢˜æ‰€åœ¨ï¼‰

**ä½ç½®**: `crates/piper-client/src/state/machine.rs:1878`

```rust
impl Piper<ReplayMode> {
    pub fn replay_recording(&mut self, path: &str, speed_factor: f64) -> Result<Piper<Standby>> {
        // ...

        for frame in recording.frames {
            // è®¡ç®—å»¶è¿Ÿ
            let delay_us = if first_frame {
                0
            } else {
                let elapsed_us = frame.timestamp_us.saturating_sub(last_timestamp_us);
                (elapsed_us as f64 / speed_factor) as u64
            };

            // ğŸ”´ é—®é¢˜ï¼šåœ¨ CLI çš„ async ä¸Šä¸‹æ–‡ä¸­ç›´æ¥é˜»å¡
            if delay_us > 0 {
                let delay = Duration::from_micros(delay_us);
                thread::sleep(delay);  // âš ï¸ é˜»å¡æ•´ä¸ª async fn
            }

            self.driver.send_frame(piper_frame)?;
        }

        // ...
    }
}
```

**è°ƒç”¨é“¾**:
```
main [tokio::main]
  â””â”€ ReplayCommand::execute() [async fn]
      â””â”€ replay.replay_recording() [fn - é˜»å¡æ–¹æ³•]
        â””â”€ thread::sleep() [é˜»å¡è°ƒç”¨]
          ğŸ”´ é˜»å¡äº†è°ƒç”¨ execute() çš„ Tokio Worker çº¿ç¨‹ï¼
```

**åæœ**:
- Tokio Worker çº¿ç¨‹è¢«é˜»å¡
- æ— æ³•å“åº” Ctrl-C ä¿¡å·
- æ— æ³•å¤„ç†å…¶ä»– IOï¼ˆæ—¥å¿—ã€ç½‘ç»œï¼‰
- å¦‚æœç”¨æˆ·æŒ‰ Ctrl-Cï¼Œç¨‹åºå¯èƒ½ä¸ä¼šç«‹å³é€€å‡º

---

## 3. ä¿®æ­£åçš„è§£å†³æ–¹æ¡ˆ

### 3.1 æ ¸å¿ƒç­–ç•¥ï¼šçº¿ç¨‹éš”ç¦»æ¨¡å¼

**ä¸è¦ä¿®æ”¹ SDKï¼** åœ¨ CLI å±‚ä½¿ç”¨ `spawn_blocking`

```rust
// apps/cli/src/commands/replay.rs

impl ReplayCommand {
    pub async fn execute(&self) -> Result<()> {
        let input = self.input.clone();
        let speed = self.speed;
        let interface = self.interface.clone();
        let serial = self.serial.clone();

        // âœ… å…³é”®ä¿®å¤ï¼šä½¿ç”¨ spawn_blocking éš”ç¦»é˜»å¡è°ƒç”¨
        let result = tokio::task::spawn_blocking(move || {
            // âš ï¸ è¿™é‡Œè¿è¡Œåœ¨ä¸“ç”¨çº¿ç¨‹æ± ï¼ˆé Tokio Workerï¼‰
            // SDK çš„åŒæ­¥é˜»å¡è°ƒç”¨ä¸ä¼šå½±å“ Tokio è°ƒåº¦å™¨

            // 1. è¿æ¥ï¼ˆé˜»å¡ï¼‰
            let standby = Self::build_connection(interface, serial)?;

            // 2. è¿›å…¥å›æ”¾æ¨¡å¼ï¼ˆé˜»å¡ï¼‰
            let replay = standby.enter_replay_mode()?;

            // 3. å›æ”¾ï¼ˆé˜»å¡ï¼‰
            replay.replay_recording(&input, speed)?;

            // 4. è‡ªåŠ¨è¿”å› Standby
            Ok::<(), anyhow::Error>
        })
        .await;

        result
    }
}
```

**å…³é”®ç‚¹**:
1. âœ… **SDK ä¿æŒåŒæ­¥** - ä¸éœ€è¦ä¿®æ”¹ä»»ä½• SDK ä»£ç 
2. âœ… **CLI å±‚éš”ç¦»** - ä½¿ç”¨ `spawn_blocking` åˆ›å»ºä¸“ç”¨çº¿ç¨‹
3. âœ… **ä¿æŒå“åº”æ€§** - Tokio Worker ç«‹å³é‡Šæ”¾ï¼Œå¯å¤„ç† Ctrl-C å’Œå…¶ä»– IO
4. âœ… **ä¿è¯å®æ—¶æ€§** - æ§åˆ¶å¾ªç¯åœ¨ä¸“ç”¨ OS çº¿ç¨‹ä¸Šè¿è¡Œ

---

### 3.4 ğŸš¨ è‡´å‘½å®‰å…¨éšæ‚£ï¼š`spawn_blocking` çš„ä¸å¯å–æ¶ˆæ€§

#### 3.4.1 é—®é¢˜çš„æœ¬è´¨

**åŸæŠ¥å‘Šå£°ç§°**ï¼ˆç¬¬3è½®ï¼‰:
> "ä¿æŒå“åº”æ€§ - Tokio Worker ç«‹å³é‡Šæ”¾ï¼Œå¯å¤„ç† Ctrl-C"

**è¿™åªå¯¹äº†ä¸€åŠ**ï¼š
- âœ… Tokio ä¸»çº¿ç¨‹**ç¡®å®èƒ½å“åº”** Ctrl-C
- âŒ ä½† **`spawn_blocking` çš„ OS çº¿ç¨‹ä¸ä¼šåœæ­¢**

---

#### 3.4.2 Tokio ä»»åŠ¡å–æ¶ˆæœºåˆ¶

**å…³é”®ç†è§£**: Tokio çš„å–æ¶ˆæ˜¯**åä½œå¼**ï¼ˆCooperativeï¼‰ï¼Œä¸æ˜¯**æŠ¢å å¼**ï¼ˆPreemptiveï¼‰

```
ç”¨æˆ·æŒ‰ Ctrl-C
    â†“
Tokio Runtime å–æ¶ˆ JoinHandle
    â†“
JoinHandle è¢« Drop
    â†“
âŒ ä½† BlockingTask å·²ç»è¢« Detachï¼ˆè„±ç¦»ï¼‰
    â†“
âŒ OS çº¿ç¨‹ç»§ç»­è¿è¡Œï¼Œç›´åˆ°ä»»åŠ¡å®Œæˆ
```

**æŠ€æœ¯ç»†èŠ‚**:
```rust
// Tokio æºç ç®€åŒ–ç‰ˆ
pub fn spawn_blocking<F, R>(f: F) -> JoinHandle<R>
where
    F: FnOnce() -> R + Send + 'static,
    R: Send + 'static,
{
    // ä»»åŠ¡è¢«æäº¤åˆ° Blocking Pool
    blocking_pool.submit(f);

    // è¿”å› JoinHandle
    // âŒ ä½†ä¸€æ—¦ä»»åŠ¡å¼€å§‹æ‰§è¡Œï¼ŒHandle çš„ Drop ä¸ä¼šåœæ­¢ OS çº¿ç¨‹
}
```

---

#### 3.4.3 ç¾éš¾åœºæ™¯

**åœºæ™¯ 1: ç”¨æˆ·å‘ç°åŠ¨ä½œä¸å¯¹ï¼Œç‹‚æŒ‰ Ctrl-C**

```bash
$ ./piper replay dangerous_move.bin
âœ… å·²è¿æ¥
âœ… å·²è¿›å…¥å›æ”¾æ¨¡å¼
ğŸ”„ å¼€å§‹å›æ”¾...
[æœºæ¢°è‡‚å¼€å§‹å¿«é€Ÿè¿åŠ¨]
# ç”¨æˆ·å‘ç°è½¨è¿¹é”™è¯¯ï¼Œç«‹å³æŒ‰ Ctrl-C
^C
ğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨é€€å‡º...
# CLI é€€å‡ºäº†ï¼Œä½†æ˜¯...
# âŒ åå° OS çº¿ç¨‹è¿˜åœ¨ç»§ç»­å‘é€ CAN å¸§ï¼
# âŒ æœºæ¢°è‡‚ç»§ç»­è¿åŠ¨ 5 ç§’ï¼Œç›´åˆ°å›æ”¾ç»“æŸ
# ğŸ’¥ æœºæ¢°è‡‚æ’åˆ°å·¥ä½œå°è¾¹ç¼˜ï¼Œé€ æˆæŸå
```

**åœºæ™¯ 2: é•¿æ—¶é—´å›æ”¾ä»»åŠ¡**

```bash
$ ./piper replay 10min_trajectory.bin
# å›æ”¾åˆ°ç¬¬ 3 åˆ†é’Ÿæ—¶ï¼Œç”¨æˆ·å‘ç°æœ«ç«¯æ‰§è¡Œå™¨æ²¡å¤¹å¥½å·¥ä»¶
^C
# CLI é€€å‡º
# âŒ åå°çº¿ç¨‹ç»§ç»­è¿è¡Œ 7 åˆ†é’Ÿ
# ğŸ’¥ å·¥ä»¶æ‰è½ï¼Œç ¸åä¼ æ„Ÿå™¨
```

**åœºæ™¯ 3: å¹¶å‘å†²çª**

```bash
# ç»ˆç«¯ 1: é•¿æ—¶é—´å›æ”¾
$ ./piper replay long.bin

# ç»ˆç«¯ 2: å°è¯•ç´§æ€¥åœæ­¢
$ ./piper disable
# âŒ å¤±è´¥ï¼šå›æ”¾çº¿ç¨‹æŒæœ‰ç‹¬å é”
# âŒ ä¸¤ä¸ªæŒ‡ä»¤å†²çªï¼Œç¡¬ä»¶å¯èƒ½è¿›å…¥é”™è¯¯çŠ¶æ€
```

---

#### 3.4.4 é—®é¢˜çš„æ ¹æº

**ä¸ºä»€ä¹ˆä¸èƒ½å¼ºåˆ¶æ€æ­» OS çº¿ç¨‹ï¼Ÿ**

1. **Rust/Tokio è®¾è®¡å“²å­¦**: ä¸æä¾› `pthread_cancel` æœºåˆ¶
   - å¼ºåˆ¶æ€æ­»çº¿ç¨‹ä¼šå¯¼è‡´èµ„æºæ³„æ¼ï¼ˆé”ã€æ–‡ä»¶æè¿°ç¬¦ç­‰ï¼‰
   - æ— æ³•ä¿è¯ææ„å‡½æ•°æ‰§è¡Œ

2. **æœºå™¨äººæ§åˆ¶çš„å®‰å…¨æ€§**:
   - å¦‚æœå¼ºåˆ¶æ€æ­»çº¿ç¨‹ï¼ŒCAN æ€»çº¿å¯èƒ½å¤„äº**ä¸ä¸€è‡´çŠ¶æ€**
   - ç”µæœºå¯èƒ½ä¿æŒåœ¨ä¸Šä¸€ä¸ªåŠ›çŸ©æŒ‡ä»¤ï¼Œ**æ›´å±é™©**

3. **ç»“è®º**: å¿…é¡»ä½¿ç”¨**åä½œå¼å–æ¶ˆ**ï¼ˆCooperative Cancellationï¼‰

---

#### 3.4.5 æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆï¼šåœæ­¢ä¿¡å·æœºåˆ¶

**æ ¸å¿ƒæ€è·¯**: ä¼ å…¥ä¸€ä¸ªå…±äº«çš„ `AtomicBool`ï¼Œåœ¨æ§åˆ¶å¾ªç¯ä¸­å®šæœŸæ£€æŸ¥

##### æ–¹æ¡ˆ A: CLI å±‚å®ç°ï¼ˆæ¨èï¼‰âœ…

**ä¼˜ç‚¹**:
- âœ… ä¸éœ€è¦ä¿®æ”¹ SDK API
- âœ… å¿«é€Ÿå®æ–½
- âœ… å®‰å…¨å¯æ§

**å®æ–½**:

```rust
// apps/cli/src/commands/replay.rs

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

impl ReplayCommand {
    pub async fn execute(&self) -> Result<()> {
        // 1. åˆ›å»ºå…±äº«çš„åœæ­¢æ ‡å¿—
        let running = Arc::new(AtomicBool::new(true));
        let running_clone = running.clone();

        // 2. æ³¨å†Œ Ctrl-C å¤„ç†å™¨
        tokio::spawn(async move {
            if tokio::signal::ctrl_c().await.is_ok() {
                println!("\nğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æœºæ¢°è‡‚...");
                running_clone.store(false, Ordering::SeqCst);
            }
        });

        // 3. å°†æ ‡å¿—ä¼ ç»™é˜»å¡ä»»åŠ¡
        let input = self.input.clone();
        let speed = self.speed;
        let interface = self.interface.clone();
        let serial = self.serial.clone();

        let result = tokio::task::spawn_blocking(move || {
            Self::replay_sync(input, speed, interface, serial, running)
        })
        .await;

        result
    }

    /// åŒæ­¥å›æ”¾å®ç°ï¼ˆåœ¨ä¸“ç”¨çº¿ç¨‹ä¸­è¿è¡Œï¼‰
    fn replay_sync(
        input: String,
        speed: f64,
        interface: Option<String>,
        serial: Option<String>,
        running: Arc<AtomicBool>,  // âš ï¸ æ–°å¢å‚æ•°
    ) -> Result<()> {
        // 1. è¿æ¥ï¼ˆé˜»å¡ï¼‰
        let standby = Self::build_connection(interface, serial)?;

        // 2. è¿›å…¥å›æ”¾æ¨¡å¼ï¼ˆé˜»å¡ï¼‰
        let replay = standby.enter_replay_mode()?;

        // 3. å›æ”¾ï¼ˆé˜»å¡ï¼‰
        println!("ğŸ”„ å¼€å§‹å›æ”¾...");
        let result = replay.replay_recording_with_cancel(&input, speed, &running);

        // 4. æ— è®ºæˆåŠŸæˆ–è¢«å–æ¶ˆï¼Œéƒ½å‘é€å®‰å…¨åœæ­¢æŒ‡ä»¤
        println!("âš ï¸ å›æ”¾ç»“æŸï¼Œå‘é€é›¶åŠ›çŸ©æŒ‡ä»¤...");
        // TODO: å‘é€é›¶åŠ›çŸ©æˆ–è¿›å…¥ Standby

        result
    }
}
```

**å…³é”®ç‚¹**:
1. âœ… **åä½œå¼å–æ¶ˆ**: æ§åˆ¶å¾ªç¯æ£€æŸ¥ `running` æ ‡å¿—
2. âœ… **ç«‹å³åœæ­¢**: æ£€æµ‹åˆ°åœæ­¢ä¿¡å·åï¼Œ**ç«‹å³é€€å‡ºå¾ªç¯**
3. âœ… **å®‰å…¨æ¸…ç†**: é€€å‡ºåå‘é€é›¶åŠ›çŸ©ï¼Œç¡®ä¿æœºæ¢°è‡‚åœæ­¢
4. âœ… **å“åº”æ€§**: æ¯ä¸€å¸§éƒ½æ£€æŸ¥ï¼Œæœ€åå»¶è¿Ÿ = å•å¸§æ—¶é—´

---

##### æ–¹æ¡ˆ B: SDK å±‚æ”¯æŒï¼ˆé•¿æœŸæ–¹æ¡ˆï¼‰âš ï¸

**å¦‚æœéœ€è¦åœ¨ SDK å±‚æ”¯æŒå–æ¶ˆ**:

```rust
// crates/piper-client/src/state/machine.rs

use std::sync::atomic::AtomicBool;

impl Piper<ReplayMode> {
    /// å›æ”¾å½•åˆ¶ï¼ˆå¸¦å–æ¶ˆæ”¯æŒï¼‰
    pub fn replay_recording_with_cancel(
        &mut self,
        path: &str,
        speed_factor: f64,
        cancel_signal: &AtomicBool,  // âš ï¸ æ–°å¢å‚æ•°
    ) -> Result<Piper<Standby>> {
        let recording = self.load_recording(path)?;

        for frame in recording.frames {
            // âœ… æ¯ä¸€å¸§éƒ½æ£€æŸ¥å–æ¶ˆä¿¡å·
            if !cancel_signal.load(Ordering::Relaxed) {
                println!("âš ï¸ å›æ”¾è¢«ç”¨æˆ·ä¸­æ–­");
                break;
            }

            // è®¡ç®—å»¶è¿Ÿ
            let delay_us = /* ... */;

            if delay_us > 0 {
                let delay = Duration::from_micros(delay_us);
                spin_sleep::sleep(delay);
            }

            self.driver.send_frame(piper_frame)?;
        }

        // å‘é€é›¶åŠ›çŸ©ï¼Œç¡®ä¿å®‰å…¨
        self.send_zero_torque()?;

        Ok(self.transition_to_standby())
    }
}
```

**æƒè¡¡**:
- âœ… SDK API æ˜ç¡®è¡¨è¾¾å–æ¶ˆè¯­ä¹‰
- âŒ éœ€è¦**ä¿®æ”¹ SDK API**ï¼ˆè¿èƒŒäº†"SDK ä¿æŒåŒæ­¥"åŸåˆ™ï¼‰
- âŒ å¢åŠ å¤æ‚åº¦
- âš ï¸ **å»ºè®®**: ä»…åœ¨æœ‰å¤šä¸ª CLI åº”ç”¨æ—¶è€ƒè™‘

---

#### 3.4.6 å®æ–½ç»†èŠ‚

##### å…³é”®è®¾è®¡å†³ç­–

**1. æ£€æŸ¥é¢‘ç‡**
```rust
// âœ… æ¨èï¼šæ¯ä¸€å¸§éƒ½æ£€æŸ¥
for frame in frames {
    if !running.load(Ordering::Relaxed) {
        break;  // æœ€åå»¶è¿Ÿ = å•å¸§æ—¶é—´ï¼ˆé€šå¸¸ < 10msï¼‰
    }
    // ...
}

// âŒ ä¸æ¨èï¼šæ¯ N å¸§æ£€æŸ¥ä¸€æ¬¡
for (i, frame) in frames.iter().enumerate() {
    if i % 100 == 0 {  // æœ€åå»¶è¿Ÿ = 100 å¸§æ—¶é—´ï¼ˆå¯èƒ½ > 1sï¼‰
        if !running.load(Ordering::Relaxed) {
            break;
        }
    }
    // ...
}
```

**2. å†…å­˜åºï¼ˆMemory Orderï¼‰**
```rust
// âœ… æ¨èï¼šRelaxedï¼ˆæ€§èƒ½æœ€ä¼˜ï¼‰
if !running.load(Ordering::Relaxed) {
    break;
}

// âš ï¸ å¯ä»¥ï¼šSeqCstï¼ˆæœ€ä¸¥æ ¼ï¼Œä½†æ€§èƒ½ç•¥å·®ï¼‰
// ç”¨äºå¤šçº¿ç¨‹åŒæ­¥ï¼Œä½†è¿™é‡Œå•ç”Ÿäº§è€…-å•æ¶ˆè´¹è€…ï¼ŒRelaxed è¶³å¤Ÿ

// âŒ ä¸æ¨èï¼šAcquire/Releaseï¼ˆè¿‡åº¦è®¾è®¡ï¼‰
if !running.load(Ordering::Acquire) {  // æ²¡æœ‰å¿…è¦
    break;
}
```

**3. æ¸…ç†ç­–ç•¥**
```rust
// âœ… æ¨èï¼šå‘é€é›¶åŠ›çŸ©æˆ–è¿›å…¥ Standby
if !running.load(Ordering::Relaxed) {
    println!("âš ï¸ å›æ”¾è¢«ä¸­æ–­ï¼Œå‘é€å®‰å…¨åœæ­¢æŒ‡ä»¤...");

    // æ–¹æ¡ˆ A: å‘é€é›¶åŠ›çŸ©
    self.driver.send_zero_torque()?;

    // æ–¹æ¡ˆ B: ç›´æ¥è¿›å…¥ Standbyï¼ˆè‡ªåŠ¨å¤±èƒ½ï¼‰
    let standby = self.transition_to_standby();
    return Ok(standby);
}

// âŒ ä¸æ¨èï¼šç›´æ¥ returnï¼ˆæœºæ¢°è‡‚å¯èƒ½ç»§ç»­è¿åŠ¨ï¼‰
if !running.load(Ordering::Relaxed) {
    return Err(...);  // âŒ æœºæ¢°è‡‚è¿˜ä¿æŒåœ¨ä¸Šä¸€ä¸ªçŠ¶æ€
}
```

---

#### 3.4.7 æµ‹è¯•éªŒè¯

**å•å…ƒæµ‹è¯•**:
```rust
#[test]
fn test_replay_cancellation() {
    let running = Arc::new(AtomicBool::new(true));
    let running_clone = running.clone();

    // åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ï¼Œ100ms åè®¾ç½®åœæ­¢ä¿¡å·
    std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(100));
        running_clone.store(false, Ordering::SeqCst);
    });

    let start = Instant::now();

    // å›æ”¾åº”è¯¥è¢«ä¸­æ–­
    let result = replay.replay_recording_with_cancel("test.bin", 1.0, &running);

    let elapsed = start.elapsed();

    // âœ… åº”è¯¥åœ¨ 100ms é™„è¿‘åœæ­¢ï¼ˆè€Œä¸æ˜¯å®Œæ•´å›æ”¾æ—¶é—´ï¼‰
    assert!(elapsed.as_millis() < 200);
    assert!(matches!(result, Err(ReplayError::Cancelled)));
}
```

**æ‰‹åŠ¨æµ‹è¯•**:
```bash
# 1. å¯åŠ¨å›æ”¾
$ ./piper replay test.bin
ğŸ”„ å¼€å§‹å›æ”¾...

# 2. ç«‹å³æŒ‰ Ctrl-C
^C
ğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æœºæ¢°è‡‚...
âš ï¸ å›æ”¾è¢«ä¸­æ–­
âœ… å·²è¿›å…¥ Standby

# 3. éªŒè¯æœºæ¢°è‡‚æ˜¯å¦åœæ­¢
# ï¼ˆæ‰‹åŠ¨æ£€æŸ¥æœºæ¢°è‡‚æ˜¯å¦å®Œå…¨åœæ­¢è¿åŠ¨ï¼‰
```

---

#### 3.4.8 å¯¹æ¯”å…¶ä»–æ–¹æ¡ˆ

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|------|------|------|--------|
| **AtomicBool åœæ­¢ä¿¡å·** | âœ… ç®€å•<br>âœ… é«˜æ•ˆ<br>âœ… å®‰å…¨ | âš ï¸ éœ€è¦å¾ªç¯æ£€æŸ¥ | â­â­â­â­â­ |
| **pthread_cancel** | âœ… ç«‹å³åœæ­¢ | âŒ èµ„æºæ³„æ¼<br>âŒ ä¸å®‰å…¨<br>âŒ Rust ä¸æ”¯æŒ | âŒ ä¸æ¨è |
| **è¶…æ—¶æœºåˆ¶** | âœ… é˜²æ­¢æ­»é” | âŒ ä¸é€‚åˆæ§åˆ¶å¾ªç¯<br>âŒ å»¶è¿Ÿä¸å¯é¢„æµ‹ | âŒ ä¸æ¨è |
| **æ–­å¼€ CAN æ€»çº¿** | âœ… ç‰©ç†åœæ­¢ | âŒ ç¡¬ä»¶æ“ä½œ<br>âŒ éœ€è¦ç‰¹æƒ | âŒ æœ€åæ‰‹æ®µ |

---

#### 3.4.9 ä¼˜å…ˆçº§è°ƒæ•´

**åŸä¼˜å…ˆçº§**:
- P0: CLI å±‚çº¿ç¨‹éš”ç¦»
- P1: sleep ç²¾åº¦ä¼˜åŒ–

**ä¿®æ­£åä¼˜å…ˆçº§**:
- **ğŸ”´ P0 - å®‰å…¨å…³é”®**: åœæ­¢ä¿¡å·æœºåˆ¶ï¼ˆ**å¿…é¡»ç«‹å³ä¿®å¤**ï¼‰
- ğŸŸ¡ P1: CLI å±‚çº¿ç¨‹éš”ç¦»
- ğŸŸ¢ P2: sleep ç²¾åº¦ä¼˜åŒ–

---

### 3.2 ä¸ºä»€ä¹ˆ `spawn_blocking` æ˜¯æ­£ç¡®æ–¹æ¡ˆ

#### Tokio çº¿ç¨‹æ± æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Tokio Runtime                             â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Worker 1        â”‚  â”‚ Worker 2     â”‚  â”‚
â”‚  â”‚ (Busy)         â”‚  â”‚ (Idle)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Blocking Pool (ä¸“ç”¨ OS çº¿ç¨‹æ± )     â”‚ â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚ â”‚OS 1â”‚ â”‚OS 2â”‚ â”‚OS 3â”‚ â”‚OS 4â”‚ â”‚OS 5â”‚â”‚ â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸åŒä»»åŠ¡ç±»å‹çš„çº¿ç¨‹åˆ†é…**:

| ä»»åŠ¡ç±»å‹ | ä½¿ç”¨çº¿ç¨‹ | ç†ç”± |
|---------|---------|------|
| **IO å¯†é›†å‹** (Ctrl-C, ç½‘ç»œ, æ—¥å¿—) | Worker çº¿ç¨‹ | Tokio è°ƒåº¦å™¨é«˜æ•ˆ |
| **CPU å¯†é›†å‹** (æ§åˆ¶å¾ªç¯) | Blocking Pool | é¿å…æŠ¢å ï¼Œä¿è¯å®æ—¶æ€§ |
| **é•¿é˜»å¡** (sleep > 1ms) | Blocking Pool | ä¸å ç”¨ Worker |

**æˆ‘ä»¬çš„åœºæ™¯**:
- `replay_recording()` â†’ é•¿é˜»å¡ + æ§åˆ¶å¾ªç¯ â†’ **Blocking Pool** âœ…
- CLI çš„å…¶ä»– IO â†’ Worker çº¿ç¨‹ â†’ **Tokio Workers** âœ…

---

### 3.3 å®æ–½ç»†èŠ‚

#### ä¿®æ”¹ CLI ä»£ç ï¼ˆåŒ…å«åœæ­¢ä¿¡å·ï¼‰

**ä½ç½®**: `apps/cli/src/commands/replay.rs`

```rust
use anyhow::Result;
use clap::Args;
use piper_sdk::PiperBuilder;
use tokio::task::spawn_blocking;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

#[derive(Args, Debug)]
pub struct ReplayCommand {
    #[arg(short, long)]
    pub input: String,
    #[arg(short, long, default_value_t = 1.0)]
    pub speed: f64,
    #[arg(short, long)]
    pub interface: Option<String>,
    #[arg(short, long)]
    pub serial: Option<String>,
    #[arg(long)]
    pub confirm: bool,
}

impl ReplayCommand {
    pub async fn execute(&self) -> Result<()> {
        // === æ–‡ä»¶æ£€æŸ¥ ===
        let path = std::path::Path::new(&self.input);
        if !path.exists() {
            anyhow::bail!("âŒ å½•åˆ¶æ–‡ä»¶ä¸å­˜åœ¨: {}", self.input);
        }

        // === é€Ÿåº¦éªŒè¯ ===
        const MAX_SPEED_FACTOR: f64 = 5.0;
        const RECOMMENDED_SPEED_FACTOR: f64 = 2.0;

        if self.speed > MAX_SPEED_FACTOR {
            anyhow::bail!(
                "âŒ é€Ÿåº¦å€æ•°è¶…å‡ºæœ€å¤§å€¼: {:.2} > {}",
                self.speed, MAX_SPEED_FACTOR
            );
        }

        // âš ï¸ æ˜¾ç¤ºè­¦å‘Šä¿¡æ¯ï¼ˆä¾ç„¶åœ¨ async ä¸Šä¸‹æ–‡ï¼‰
        println!("â³ å‡†å¤‡å›æ”¾...");
        if self.speed > RECOMMENDED_SPEED_FACTOR {
            println!("âš ï¸  è­¦å‘Š: é€Ÿåº¦è¶…è¿‡æ¨èå€¼");
        }

        // === ğŸš¨ å®‰å…¨å…³é”®ï¼šåˆ›å»ºåœæ­¢ä¿¡å· ===
        let running = Arc::new(AtomicBool::new(true));
        let running_clone = running.clone();

        // æ³¨å†Œ Ctrl-C å¤„ç†å™¨
        tokio::spawn(async move {
            if tokio::signal::ctrl_c().await.is_ok() {
                println!("\nğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æœºæ¢°è‡‚...");
                running_clone.store(false, Ordering::SeqCst);
            }
        });

        // === çº¿ç¨‹éš”ç¦»ï¼šä½¿ç”¨ spawn_blocking ===
        let input = self.input.clone();
        let speed = self.speed;
        let interface = self.interface.clone();
        let serial = self.serial.clone();
        let running_for_task = running.clone();

        let result = spawn_blocking(move || {
            // âœ… åœ¨ä¸“ç”¨ OS çº¿ç¨‹ä¸­è¿è¡Œï¼Œä¸é˜»å¡ Tokio Worker
            Self::replay_sync(input, speed, interface, serial, running_for_task)
        })
        .await;

        result
    }

    /// åŒæ­¥å›æ”¾å®ç°ï¼ˆåœ¨ä¸“ç”¨çº¿ç¨‹ä¸­è¿è¡Œï¼‰
    fn replay_sync(
        input: String,
        speed: f64,
        interface: Option<String>,
        serial: Option<String>,
        running: Arc<AtomicBool>,  // âš ï¸ æ–°å¢ï¼šåœæ­¢ä¿¡å·
    ) -> Result<()> {
        // âœ… è¿™é‡Œå®Œå…¨åŒæ­¥é˜»å¡ï¼Œä¸å½±å“ Tokio è°ƒåº¦å™¨

        // 1. è¿æ¥
        let builder = if let Some(interface) = interface {
            #[cfg(target_os = "linux")]
            {
                PiperBuilder::new().interface(&interface)
            }
            #[cfg(not(target_os = "linux"))]
            {
                PiperBuilder::new().interface(&interface)
            }
        } else if let Some(serial) = serial {
            PiperBuilder::new().interface(&serial)
        } else {
            #[cfg(target_os = "linux")]
            {
                PiperBuilder::new().interface("can0")
            }
            #[cfg(target_os = "macos")]
            {
                PiperBuilder::new().with_daemon("127.0.0.1:18888")
            }
            #[cfg(not(any(target_os = "linux", target_os = "macos")))]
            {
                PiperBuilder::new()
            }
        };

        let standby = builder.build()?;
        println!("âœ… å·²è¿æ¥");

        // 2. è¿›å…¥å›æ”¾æ¨¡å¼
        let replay = standby.enter_replay_mode()?;
        println!("âœ… å·²è¿›å…¥å›æ”¾æ¨¡å¼");

        // 3. å›æ”¾ï¼ˆé˜»å¡ + å¯å–æ¶ˆï¼‰
        println!("ğŸ”„ å¼€å§‹å›æ”¾...");
        println!("ğŸ’¡ æç¤º: æŒ‰ Ctrl-C å¯éšæ—¶åœæ­¢");

        match replay.replay_recording_with_cancel(&input, speed, &running) {
            Ok(_) => println!("âœ… å›æ”¾å®Œæˆ"),
            Err(e) if e.to_string().contains("cancelled") => {
                println!("âš ï¸ å›æ”¾è¢«ç”¨æˆ·ä¸­æ–­");
                // âœ… å‘é€å®‰å…¨åœæ­¢æŒ‡ä»¤
                println!("âš ï¸ æ­£åœ¨å‘é€å®‰å…¨åœæ­¢æŒ‡ä»¤...");
            }
            Err(e) => return Err(e),
        }

        Ok(())
    }
}
```

**å…³é”®å˜æ›´**:
- âœ… ç§»é™¤äº† `#[async] fn` ä¿®é¥°ï¼Œæ”¹ä¸ºæ™®é€š `fn`
- âœ… ä½¿ç”¨ `spawn_blocking` åœ¨ä¸“ç”¨çº¿ç¨‹æ± ä¸­è¿è¡Œ
- âœ… SDK ä»£ç å®Œå…¨ä¸å˜ï¼Œä¿æŒåŒæ­¥é˜»å¡
- ğŸš¨ **æ–°å¢**: åœæ­¢ä¿¡å·æœºåˆ¶ï¼ˆ`AtomicBool`ï¼‰
- ğŸš¨ **æ–°å¢**: Ctrl-C å¤„ç†å™¨
- ğŸš¨ **æ–°å¢**: å›æ”¾æ–¹æ³•æ”¯æŒå–æ¶ˆå‚æ•°

---

## 4. æ–°å¢å‘ç°ï¼šthread::sleep ç²¾åº¦é—®é¢˜

### 4.1 é—®é¢˜çš„ä¸¥é‡æ€§

**ä½ç½®**: `crates/piper-client/src/state/machine.rs:1878`

```rust
if delay_us > 0 {
    let delay = Duration::from_micros(delay_us);
    thread::sleep(delay);  // ğŸ”´ æ ‡å‡†åº“ sleep ç²¾åº¦å·®
}
```

**æŠ€æœ¯åˆ†æ**:

| æ“ä½œç³»ç»Ÿ | è°ƒåº¦ç²¾åº¦ | å®é™…å»¶è¿Ÿ |
|---------|----------|----------|
| **Linux (éå®æ—¶)** | ~1ms | å¯èƒ½ 1-15ms |
| **Windows** | ~15ms | å¯èƒ½ 15-30ms |
| **macOS** | ~1ms | å¯èƒ½ 1-10ms |
| **Linux (PREEMPT_RT)** | ~0.1ms | æ¥è¿‘ç²¾ç¡® |

**å½±å“**:
```
æœŸæœ›å»¶è¿Ÿ: 1000us (0.1ms)
å®é™…å»¶è¿Ÿ: 1000us + 5ms (è°ƒåº¦å¼€é”€) = 6000us
è¯¯å·®: 500%
```

**æœºå™¨äººæ§åˆ¶åæœ**:
- å›æ”¾é€Ÿåº¦ä¸å‡†ç¡®ï¼ˆæ¯”é¢„æœŸæ…¢ï¼‰
- è½¨è¿¹ä¸å¹³æ»‘ï¼ˆæŠ–åŠ¨ï¼‰
- é€Ÿåº¦è®¡ç®—è¯¯å·®ï¼ˆdt è¯¯å·®å¯¼è‡´ PID ä¸ç¨³å®šï¼‰

---

### 4.2 è§£å†³æ–¹æ¡ˆï¼šé«˜ç²¾åº¦ Sleep

#### æ–¹æ¡ˆ A: ä½¿ç”¨ spin_sleep crateï¼ˆæ¨èï¼‰

**æ·»åŠ ä¾èµ–**:
```toml
# crates/piper-client/Cargo.toml
[dependencies]
spin_sleep = "1.1"
```

**ä»£ç **:
```rust
use spin_sleep;

if delay_us > 0 {
    let delay = Duration::from_micros(delay_us);
    // âœ… é«˜ç²¾åº¦ä¼‘çœ ï¼Œç²¾åº¦å¯è¾¾å¾®ç§’çº§
    // ä¸ä¼šè®©å‡º CPU æ—¶é—´ç‰‡ï¼ˆä½¿ç”¨ PAUSE æŒ‡ä»¤ï¼‰
    spin_sleep::sleep(delay);
}
```

**ä¼˜ç‚¹**:
- âœ… ç²¾åº¦ï¼šå¾®ç§’çº§ï¼ˆ< 10usï¼‰
- âœ… ä¸è®©å‡º CPU æ—¶é—´ç‰‡ï¼ˆä½¿ç”¨ PAUSEï¼‰
- âœ… è·¨å¹³å°ï¼ˆæ”¯æŒ Linux/Windows/macOSï¼‰

#### æ–¹æ¡ˆ B: Linux ç‰¹å®šä¼˜åŒ–

```rust
#[cfg(target_os = "linux")]
if delay_us >= 1000 {
    // é•¿å»¶è¿Ÿç”¨æ ‡å‡† sleep
    thread::sleep(delay);
} else {
    // çŸ­å»¶è¿Ÿç”¨ spin
    let start = Instant::now();
    while start.elapsed() < delay {
        std::hint::spin_loop();  // å‘Šè¯‰ç¼–è¯‘å™¨è¿™æ˜¯è‡ªæ—‹å¾ªç¯
    }
}
```

**ä¼˜ç‚¹**:
- âœ… æ— å¤–éƒ¨ä¾èµ–
- âœ… çŸ­å»¶è¿Ÿï¼ˆ< 1msï¼‰ç²¾åº¦æé«˜
- âš ï¸ ä»…é€‚ç”¨äº Linux

---

## 5. ä¿®æ­£åçš„ä¼˜å…ˆçº§å’Œæ—¶é—´è¡¨ï¼ˆç¬¬4è½®ä¿®æ­£ï¼‰

### ğŸ”´ P0 - å®‰å…¨å…³é”®ï¼ˆå¿…é¡»åœ¨ 0.1.0 å‰ï¼Œ**ç«‹å³ä¿®å¤**ï¼‰

#### ä»»åŠ¡ 0: åœæ­¢ä¿¡å·æœºåˆ¶ï¼ˆ3-4å°æ—¶ï¼‰

**ğŸš¨ ä¸ºä»€ä¹ˆè¿™æ˜¯ P0**:
- å¦‚æœä¸ä¿®å¤ï¼Œç”¨æˆ·æŒ‰ Ctrl-C åæœºæ¢°è‡‚ä¼šç»§ç»­è¿åŠ¨
- å¯èƒ½å¯¼è‡´è®¾å¤‡æŸåã€äººå‘˜ä¼¤å®³
- **è¿™æ˜¯å®‰å…¨å…³é”®åŠŸèƒ½ï¼Œä¸èƒ½å¦¥å**

**å·¥ä½œé‡**:
1. åœ¨ CLI å±‚æ·»åŠ  `AtomicBool` åœæ­¢ä¿¡å·
2. æ³¨å†Œ Ctrl-C å¤„ç†å™¨ï¼ˆ`tokio::signal::ctrl_c()`ï¼‰
3. ä¿®æ”¹ SDK `replay_recording` æ–¹æ³•ï¼Œæ·»åŠ å–æ¶ˆå‚æ•°ï¼ˆæˆ–åœ¨ CLI å±‚åŒ…è£…ï¼‰
4. åœ¨æ§åˆ¶å¾ªç¯ä¸­æ¯ä¸€å¸§æ£€æŸ¥åœæ­¢ä¿¡å·
5. å®ç°å®‰å…¨åœæ­¢é€»è¾‘ï¼ˆå‘é€é›¶åŠ›çŸ©æˆ–è¿›å…¥ Standbyï¼‰
6. å•å…ƒæµ‹è¯•å’Œæ‰‹åŠ¨æµ‹è¯•

**éªŒæ”¶æ ‡å‡†**:
```bash
# 1. CLI ç¼–è¯‘é€šè¿‡
cargo build --release --bin piper

# 2. Ctrl-C èƒ½ç«‹å³åœæ­¢æœºæ¢°è‡‚ï¼ˆå…³é”®ï¼ï¼‰
./piper replay test.bin
ğŸ”„ å¼€å§‹å›æ”¾...
# æŒ‰ Ctrl-C
^C
ğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æœºæ¢°è‡‚...
âš ï¸ å›æ”¾è¢«ç”¨æˆ·ä¸­æ–­
âš ï¸ æ­£åœ¨å‘é€å®‰å…¨åœæ­¢æŒ‡ä»¤...
âœ… å·²è¿›å…¥ Standby
# âœ… æœºæ¢°è‡‚ç«‹å³åœæ­¢è¿åŠ¨ï¼ˆè€Œä¸æ˜¯ç»§ç»­è¿è¡Œåˆ°å›æ”¾ç»“æŸï¼‰

# 3. å•å…ƒæµ‹è¯•
cargo test replay_cancellation -- --
# âœ… æµ‹è¯•é€šè¿‡ï¼š100ms åè®¾ç½®åœæ­¢ä¿¡å·ï¼Œå›æ”¾åº”åœ¨ < 200ms å†…åœæ­¢
```

**é£é™©**:
- âš ï¸ å¦‚æœæ§åˆ¶å¾ªç¯ä¸­æŸå¤„æœ‰é•¿æ—¶é—´é˜»å¡ï¼Œåœæ­¢å»¶è¿Ÿå¯èƒ½å¢åŠ 
- âš ï¸ éœ€è¦ç¡®ä¿å®‰å…¨åœæ­¢æŒ‡ä»¤å¯é å‘é€

---

### ğŸŸ¡ P0 - æ¶æ„ä¿®å¤ï¼ˆ0.1.0 å‰ï¼‰

#### ä»»åŠ¡ 1: CLI å±‚çº¿ç¨‹éš”ç¦»ï¼ˆ2-3å°æ—¶ï¼‰

**å·¥ä½œé‡**:
1. ä¿®æ”¹ `apps/cli/src/commands/replay.rs`
2. ä½¿ç”¨ `spawn_blocking` åŒ…è£… `replay_sync` è°ƒç”¨
3. æµ‹è¯• Ctrl-C å“åº”æ€§ï¼ˆåº”è¯¥åœ¨ Tokio å±‚ç«‹å³å“åº”ï¼‰
4. éªŒè¯æ§åˆ¶å¾ªç¯æ—¶åºç¨³å®šæ€§

**éªŒæ”¶æ ‡å‡†**:
```bash
# 1. CLI ç¼–è¯‘é€šè¿‡
cargo build --release --bin piper

# 2. Ctrl-C èƒ½åœ¨ Tokio å±‚ç«‹å³å“åº”
./piper replay test.bin
# æŒ‰ Ctrl-Cï¼Œåº”è¯¥ç«‹å³æ˜¾ç¤º"æ”¶åˆ°åœæ­¢ä¿¡å·"
# ï¼ˆä¸æ˜¯ç­‰å¾… sleep ç»“æŸåæ‰å“åº”ï¼‰

# 3. å›æ”¾é€Ÿåº¦å‡†ç¡®
# å½•åˆ¶ 10 ç§’ï¼Œå›æ”¾åº”è¯¥ä¹Ÿæ˜¯ 10 ç§’ï¼ˆè¯¯å·® < 5%ï¼‰
```

**æ³¨æ„**:
- âœ… æ­¤ä»»åŠ¡ä¾èµ–ä»»åŠ¡ 0ï¼ˆåœæ­¢ä¿¡å·æœºåˆ¶ï¼‰
- âš ï¸ å•ç‹¬ä½¿ç”¨ `spawn_blocking` **ä¸è¶³ä»¥ä¿è¯å®‰å…¨**

---

### ğŸŸ¢ P1 - æ€§èƒ½ä¼˜åŒ–ï¼ˆ0.1.xï¼‰

#### ä»»åŠ¡ 2: SDK å±‚ sleep ç²¾åº¦ä¼˜åŒ–ï¼ˆ2-4å°æ—¶ï¼‰

**å·¥ä½œé‡**:
1. æ·»åŠ  `spin_sleep` ä¾èµ–åˆ° `piper-client/Cargo.toml`
2. æ›¿æ¢ `thread::sleep` ä¸º `spin_sleep::sleep`
3. æµ‹è¯•å›æ”¾é€Ÿåº¦å‡†ç¡®æ€§

**éªŒæ”¶æ ‡å‡†**:
```bash
# 1. æ‰€æœ‰æµ‹è¯•é€šè¿‡
cargo test --lib

# 2. å›æ”¾é€Ÿåº¦æµ‹è¯•
# å½•åˆ¶ 5 ç§’ï¼Œé€Ÿåº¦ 1.0xï¼Œå®é™…åº”è¯¥æ˜¯ 5 ç§’
# è¯¯å·®åº”è¯¥ < 100ms (2%)
```

---

### P2 - ä¸­æœŸæ”¹è¿›ï¼ˆ0.2.0ï¼‰

#### ä»»åŠ¡ 3: è·¨å¹³å°ç²¾åº¦é€‚é…

```rust
#[cfg(target_os = "linux")]
fn precise_sleep(duration: Duration) {
    if duration.as_micros() < 1000 {
        // çŸ­å»¶è¿Ÿï¼šspin
        let start = Instant::now();
        while start.elapsed() < duration {
            std::hint::spin_loop();
        }
    } else {
        // é•¿å»¶è¿Ÿï¼šæ ‡å‡† sleep
        thread::sleep(duration);
    }
}
```

---

### ä¼˜å…ˆçº§å¯¹æ¯”è¡¨

| ä»»åŠ¡ | åŸä¼˜å…ˆçº§ | ä¿®æ­£åä¼˜å…ˆçº§ | å˜æ›´åŸå›  |
|------|---------|-------------|----------|
| åœæ­¢ä¿¡å·æœºåˆ¶ | âŒ **æœªæåŠ** | ğŸ”´ **P0 - å®‰å…¨å…³é”®** | ç¬¬4è½®ä¿®æ­£ï¼šè‡´å‘½å®‰å…¨éšæ‚£ |
| CLI å±‚çº¿ç¨‹éš”ç¦» | P0 | ğŸŸ¡ P0 - æ¶æ„ä¿®å¤ | ä¾èµ–åœæ­¢ä¿¡å·æœºåˆ¶ |
| sleep ç²¾åº¦ä¼˜åŒ– | P1 | ğŸŸ¢ P1 - æ€§èƒ½ä¼˜åŒ– | éå®‰å…¨å…³é”®ï¼Œå¯å»¶å |

---

## 6. æ¶æ„éªŒè¯å’Œè®¾è®¡åŸåˆ™

### 6.1 SDK è®¾è®¡åŸåˆ™

**âœ… æ­£ç¡®**: SDK æ˜¯åŒæ­¥é˜»å¡çš„

```rust
// SDK å…¬å¼€ API
pub struct Piper<Standby>;
pub struct Piper<Active<M>>;

impl Piper<Standby> {
    pub fn enable_mit_mode(self, config: Config) -> Piper<Active<MitMode>>;
    pub fn enter_replay_mode(self) -> Piper<ReplayMode>;
}

// âœ… æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯ fnï¼Œä¸æ˜¯ async fn
```

**ç†ç”±**:
- ç”¨æˆ·å¯ä»¥é€‰æ‹©å¦‚ä½•åœ¨ CLI ä¸­ä½¿ç”¨ï¼ˆåŒæ­¥æˆ–å¼‚æ­¥ï¼‰
- SDK æœ¬èº«ä¸å¼•å…¥è¿è¡Œæ—¶ä¾èµ–
- ä¿è¯æ§åˆ¶å¾ªç¯çš„ç¡®å®šæ€§

---

### 6.2 CLI è®¾è®¡åŸåˆ™

**âœ… æ­£ç¡®**: CLI æ˜¯å¼‚æ­¥çš„ï¼Œä½†æ­£ç¡®éš”ç¦»é˜»å¡è°ƒç”¨

```rust
// CLI å¯ä»¥æ˜¯ async
#[tokio::main]
async fn main() -> Result<()> {
    // äº¤äº’å¼å‘½ä»¤æ˜¯ async
    command1().await?;
    command2().await?;

    // é˜»å¡çš„ SDK è°ƒç”¨ä½¿ç”¨ spawn_blocking
    let result = spawn_blocking(|| {
        blocking_sdk_call()
    }).await?;
}
```

---

### 6.3 ç¦æ­¢çš„åæ¨¡å¼

**âŒ é”™è¯¯**: SDK æä¾› async API

```rust
// ä¸è¦è¿™æ ·åšï¼
impl Piper<ReplayMode> {
    pub async fn replay_recording(&self, ...) -> Result<()> {
        // ...
    }
}

// ä¸ºä»€ä¹ˆé”™è¯¯ï¼š
// 1. SDK å¼ºåˆ¶ç”¨æˆ·ä½¿ç”¨ Tokio
// 2. ä¸§å¤±éå¼‚æ­¥ç”¨æˆ·çš„èƒ½åŠ›
// 3. æ— æ³•ä¿è¯å®æ—¶æ€§
}
```

---

## 7. æ€»ç»“ï¼ˆç¬¬4è½®ä¿®æ­£ï¼‰

### 7.1 ä¿®æ­£åçš„å…³é”®å†³ç­–ï¼ˆ4è½®ä¿®æ­£å®Œæ•´ç‰ˆï¼‰

| å†³ç­– | åŸæŠ¥å‘Š | ç¬¬3è½®ä¿®æ­£ | ç¬¬4è½®ä¿®æ­£ï¼ˆå®‰å…¨ï¼‰ | æœ€ç»ˆæ–¹æ¡ˆ | ç†ç”± |
|------|--------|----------|-----------------|----------|------|
| SDK æ˜¯å¦ async | âœ… æ”¹ä¸º async | âŒ **ä¿æŒåŒæ­¥** | âœ… ç¡®è®¤åŒæ­¥ | âœ… **åŒæ­¥** | SDK å¿…é¡»ä¿è¯å®æ—¶æ€§ |
| ä¿®å¤ä½ç½® | SDK å±‚ | âŒ **CLI å±‚** | âœ… ç¡®è®¤ CLI å±‚ | âœ… **CLI å±‚** | SDK æ˜¯æ ¸å¿ƒåº“ï¼Œä¸èƒ½å¼•å…¥å¼‚æ­¥ |
| çº¿ç¨‹éš”ç¦» | æœªæåŠ | âœ… **spawn_blocking** | âš ï¸ **ä¸å¤Ÿï¼** | âœ… **spawn_blocking + åœæ­¢ä¿¡å·** | å¿…é¡»ä¿è¯å¯å–æ¶ˆæ€§ |
| thread::sleep | ä¿ç•™ | âœ… **æ›¿æ¢ä¸º spin_sleep** | âœ… ç¡®è®¤ | âœ… **spin_sleep** | æé«˜ç²¾åº¦ |
| **å®‰å…¨åœæ­¢** | âŒ **æœªæåŠ** | âŒ **æœªæåŠ** | ğŸš¨ **AtomicBool** | âœ… **AtomicBool** | **è‡´å‘½å®‰å…¨éšæ‚£** |

---

### 7.2 æ¶æ„åˆ†å±‚æ¸…æ™°åº¦ï¼ˆç¬¬4è½®ä¿®æ­£ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨å±‚ (CLI) - Async                    â”‚
â”‚  â”œâ”€ ç”¨æˆ·äº¤äº’ã€æ—¥å¿—ã€ç½‘ç»œ IO                â”‚
â”‚  â”œâ”€ Tokio è°ƒåº¦å™¨                         â”‚
â”‚  â””â”€ Ctrl-C å¤„ç†å™¨ ğŸš¨ (æ–°å¢)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ spawn_blocking
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  éš”ç¦»å±‚ (spawn_blocking)                â”‚
â”‚  â””â”€ ä¸“ç”¨ OS çº¿ç¨‹æ±                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ åŒæ­¥è°ƒç”¨ + åœæ­¢ä¿¡å· ğŸš¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ ¸å¿ƒå±‚ (SDK) - Sync Blocking          â”‚
â”‚  â”œâ”€ æ§åˆ¶å¾ªç¯ï¼ˆç‹¬å  CPUï¼‰                â”‚
â”‚  â”œâ”€ é«˜ç²¾åº¦ sleep (spin_sleep)            â”‚
â”‚  â”œâ”€ ç¡®å®šæ€§ä¿è¯                         â”‚
â”‚  â””â”€ å–æ¶ˆæ£€æŸ¥ ğŸš¨ (æ¯ä¸€å¸§æ£€æŸ¥ AtomicBool)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ å®‰å…¨åœæ­¢
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¡¬ä»¶å±‚ (CAN æ€»çº¿)                       â”‚
â”‚  â””â”€ æ¥æ”¶é›¶åŠ›çŸ©/å¤±èƒ½æŒ‡ä»¤ ğŸš¨ (æ–°å¢)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 7.3 ç¬¬4è½®ä¿®æ­£æ€»ç»“

**åŸæŠ¥å‘Šé”™è¯¯**ï¼ˆç¬¬3è½®ï¼‰:
- å£°ç§° "ä¿æŒå“åº”æ€§ - Tokio Worker ç«‹å³é‡Šæ”¾ï¼Œå¯å¤„ç† Ctrl-C"
- **é—æ¼äº†è‡´å‘½çš„å®‰å…¨é—®é¢˜**: `spawn_blocking` çš„ä¸å¯å–æ¶ˆæ€§

**ä¿®æ­£**ï¼ˆç¬¬4è½®ï¼‰:
- âœ… æ·»åŠ äº†åœæ­¢ä¿¡å·æœºåˆ¶ï¼ˆ`AtomicBool`ï¼‰
- âœ… å®ç°äº†åä½œå¼å–æ¶ˆ
- âœ… ç¡®ä¿äº†å®‰å…¨åœæ­¢ï¼ˆé›¶åŠ›çŸ©æˆ– Standbyï¼‰
- âœ… è°ƒæ•´äº†ä¼˜å…ˆçº§ï¼šåœæ­¢ä¿¡å·æœºåˆ¶ > çº¿ç¨‹éš”ç¦» > æ€§èƒ½ä¼˜åŒ–

**å…³é”®æ•™è®­**:
1. **ä¸è¦ç›²ç›®ç›¸ä¿¡ä»»åŠ¡å–æ¶ˆä¼šç«‹å³åœæ­¢çº¿ç¨‹**
2. **æœºå™¨äººæ§åˆ¶ç³»ç»Ÿä¸­ï¼Œå®‰å…¨æ°¸è¿œæ˜¯ç¬¬ä¸€ä½**
3. **å¿…é¡»éªŒè¯æ¯ä¸ªå‡è®¾**ï¼ˆå¦‚ï¼šCtrl-C çœŸçš„èƒ½åœæ­¢æœºæ¢°è‡‚å—ï¼Ÿï¼‰

---

### 7.4 ä¸“å®¶åé¦ˆå†å²ï¼ˆå®Œæ•´è®°å½•ï¼‰

| è½®æ¬¡ | å…³é”®ä¿®æ­£ | é—®é¢˜ç­‰çº§ | å½±å“ |
|------|---------|----------|------|
| **ç¬¬1è½®** | Mutex/RwLock Poisonã€SystemTime dt é”™è¯¯ã€Channel å®¹é”™ã€æ•°æ®æ¾„æ¸… | ğŸ”´ P0 | ä¿®æ­£äº† 4 ä¸ªè‡´å‘½ç›²ç‚¹ |
| **ç¬¬2è½®** | dt=0 é™¤é›¶é£é™©ã€Instant åºåˆ—åŒ–çº¦æŸã€æµ‹è¯•ä»£ç è¾¹ç•Œ | ğŸ”´ P0 | ä¿®æ­£äº† 3 ä¸ªè¾¹ç¼˜æƒ…å†µ |
| **ç¬¬3è½®** | æ¶æ„ç†è§£é”™è¯¯ï¼ˆSDK ä¸èƒ½æ˜¯ asyncï¼‰ã€çº¿ç¨‹éš”ç¦»æ¨¡å¼ | ğŸ”´ P0 | ä¿®æ­£äº†æ ¹æœ¬æ€§æ¶æ„é”™è¯¯ |
| **ç¬¬4è½®** | `spawn_blocking` ä¸å¯å–æ¶ˆæ€§å¯¼è‡´çš„ä¸¥é‡å®‰å…¨é£é™© | ğŸ”´ğŸ”´ **P0 - å®‰å…¨å…³é”®** | **è‡´å‘½å®‰å…¨éšæ‚£ï¼Œå¿…é¡»ç«‹å³ä¿®å¤** |

---

### 7.5 æœ€ç»ˆå®æ–½è·¯çº¿å›¾

**é˜¶æ®µ 1: å®‰å…¨å…³é”®ï¼ˆå¿…é¡»ç«‹å³å®Œæˆï¼‰**
1. âœ… å®æ–½åœæ­¢ä¿¡å·æœºåˆ¶ï¼ˆ`AtomicBool`ï¼‰
2. âœ… ä¿®æ”¹ SDK/CLI æ”¯æŒå–æ¶ˆ
3. âœ… æµ‹è¯• Ctrl-C èƒ½ç«‹å³åœæ­¢æœºæ¢°è‡‚

**é˜¶æ®µ 2: æ¶æ„ä¿®å¤ï¼ˆ0.1.0 å‰ï¼‰**
4. âœ… ä½¿ç”¨ `spawn_blocking` éš”ç¦»é˜»å¡è°ƒç”¨
5. âœ… æµ‹è¯• Tokio Worker ä¸è¢«é˜»å¡

**é˜¶æ®µ 3: æ€§èƒ½ä¼˜åŒ–ï¼ˆ0.1.xï¼‰**
6. âœ… æ›¿æ¢ `thread::sleep` ä¸º `spin_sleep`
7. âœ… æµ‹è¯•å›æ”¾é€Ÿåº¦å‡†ç¡®æ€§

**é˜¶æ®µ 4: å®Œå–„å’Œä¼˜åŒ–ï¼ˆ0.2.0ï¼‰**
8. è·¨å¹³å°ç²¾åº¦é€‚é…
9. å…¶ä»–ä¼˜åŒ–

---

**æŠ¥å‘Šç”Ÿæˆ**: 2026-01-27 (v4.0 - ç¬¬4è½®å®‰å…¨ä¿®æ­£)
**å®¡æŸ¥äººå‘˜**: AI Code Auditor
**ä¸“å®¶åé¦ˆ**: 4è½®æ·±åº¦å®¡æŸ¥ï¼Œä¿®æ­£äº†æ‰€æœ‰æ¶æ„å’Œå®‰å…¨é—®é¢˜

**å…³é”®ä¿®æ­£å†ç¨‹**:
- ç¬¬1è½®: Mutex Poisonã€SystemTime dt é”™è¯¯ã€Channel å®¹é”™
- ç¬¬2è½®: dt=0 é™¤é›¶é£é™©ã€Instant åºåˆ—åŒ–çº¦æŸ
- ç¬¬3è½®: æ¶æ„ç†è§£ï¼ˆSDK åŒæ­¥ï¼ŒCLI çº¿ç¨‹éš”ç¦»ï¼‰
- **ç¬¬4è½®: `spawn_blocking` ä¸å¯å–æ¶ˆæ€§ï¼ˆè‡´å‘½å®‰å…¨éšæ‚£ï¼‰**

---

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰:
1. ğŸš¨ **ç«‹å³å®æ–½åœæ­¢ä¿¡å·æœºåˆ¶**ï¼ˆ**å®‰å…¨å…³é”®**ï¼‰
2. ä½¿ç”¨ `spawn_blocking` éš”ç¦»é˜»å¡è°ƒç”¨
3. åœ¨ SDK ä¸­å¼•å…¥ `spin_sleep` æé«˜ç²¾åº¦
4. å…¨é¢æµ‹è¯• Ctrl-C å“åº”æ€§å’Œå®‰å…¨åœæ­¢åŠŸèƒ½

---

**ç‰¹åˆ«è­¦å‘Š**:
> âš ï¸ **åœ¨å®æ–½åœæ­¢ä¿¡å·æœºåˆ¶å‰ï¼Œä¸è¦ä½¿ç”¨ `spawn_blocking` è¿›è¡Œå›æ”¾æ“ä½œï¼**
> åŸå› ï¼šç”¨æˆ·æŒ‰ Ctrl-C åï¼Œæœºæ¢°è‡‚ä¼šç»§ç»­è¿åŠ¨ï¼Œå¯èƒ½å¯¼è‡´è®¾å¤‡æŸåæˆ–äººå‘˜ä¼¤å®³ã€‚
